unit tagslist;

{$mode objfpc}{$H+}
{$modeswitch classicprocvars+}


{$ifopt D+}{$define DEBUG}{$endif}

{$ifdef DEBUG}
{$Info Debug not enabled for tagslist unit}
{$endif}
//{$ Note Message text}
//{$Warning Warning Message text}
//{$Hint Warning Message text}
//{$Error  Error Message text}
//{$Fatal  Error Message text}
//{$Stop  Error Message text}


//sdfasdfdfsdfdfs
{@todo lav record h√•ndtering som samling af tagunits
Assumption: a pointer to a record is unique even if it points to a different record type.

How to write file with records with pointers to other records:
* open stream or text file for writing
* InitStream(<streamhandle>); //writes a fileheader and clears  tables for record handliong
*
}


interface

uses
  Classes, SysUtils, StringStreamer;

const
  FINDERROR_POSITION_BEYOND_STRING = -2;
  FINDERROR_DID_NOT_FIND =-1;
  FINDERROR_NO_ERROR = 0;

  ADDERROR_ITEM_ALREADY_EXISTS = - 1000;
  ADDERROR_MEMORY_ALLOCATION_ERROR = - 1001;
  ADDERROR_ARRAY_ERROR = - 1002;

  VarTypeTagName = vt_olestr;  //Unicodestring is transported as OLE string
  VarTypeTagType = vt_int32;   //Needs type cast
  VarTypeTagId   = vt_int64;   //
  VarTypeValue   = vt_unknown; //Value is a Variant and thus unknown

type
  TTagString = UnicodeString;
  TTagId = Int64;
  TTagType =  (TT_Unit_V1,          //a single unit is a tag as part of something larger e.g. a record
               TT_Record_V1,        //A start of a record. Value is the type name for the record type, TagId is an autogenerated replacement for the pointer to the record
               TT_pointer_ref_V1,   //A reference to pointer to a record (only pointer to records are allowed now)
               TT_Global_V1,        //A global definition. This has to be at the start of a file. All later global tags are ignored after the first TTagType of any other type..
               TT_extension_V1);
  p_TRecordHeader = ^TRecordHeader;
  TRecordHeader = Record
    {$ifdef DEBUG}
    magicNumber:Uint32; ///< initialized to contain a special number so pointers can be checked for validity in debug mode
    {$endif}
    prev, next: p_TRecordHeader;
    ID:uint32; ///< TypeId (must be unique)
  end;

  TTag=class
    private

    public
      TagType:TTagType;
      TagName:TTagString; //Name of tag/record
      TagId:TTagId;  //must be unique id
      value:variant; //payload for tag/for record start it must be recordname as text
      StrParser:TStreamStringParser;

      constructor Create(tag:TTagString; id:integer; newvalue:variant; Newtagtype:TTagType);
      Destructor Destroy; virtual;
      function ToStr: UTF8String;
      function FromStr(InputStr:UTF8String):TStringConversionError;
      function TagIdToStreamString(source:TTagString; var error:TStringConversionError):String;
      function TagStrToStreamString(NewTagName: TTagString; var error:TStringConversionError):String;
      function TagIdToStreamString(NewTagID: TTagId; var error:TStringConversionError):String;
  end;


  //Used to accumulate tags for a record or a list of global tags at the start of a file
  TTagsList = class
    private
      current_idx:TTagId;
    public
      TagList : TList;
      { Public declarations }
      constructor Create;
      Destructor  Destroy; override;
      function FindTag (findname:string):Int64;
  //      function FindTagId (findname:string):integer;
      function FindTagId (findid:TTagId):int64;

      function AddTag(name:TTagString; id:TTagId; newvalue:variant; NewTagType:TTagType):TTagId;
      function RemoveTag(name:TTagString):TTagId;
      function GetTag(id:TTagId):TTag;
      function Reset_for_enumerate:TTagId;
      //function Enumerate_tag:TTag;
      function Enumerate_tag(var errors:integer):TTag;
  end;

//  function TagSetToStreamString(tagName: TTagstring; TagID:TTagId;  tagvalue:variant;var error:TStringConversionError):String;

implementation

var
  e:TStringConversionError;

function TTag.TagIdToStreamString(source:TTagString; var error:TStringConversionError):String;
var
    TempStr:UTF8String;

begin
  error := SCE_ClearError;
  TempStr:=source;
  Result := Self.StrParser.variantToStreamString(source, error);
end;

function TTag.TagStrToStreamString(NewTagName: TTagString; var error:TStringConversionError):String;
begin
  Result := Self.StrParser.VariantToStreamString(NewTagName, error);
end;

function TTag.TagIdToStreamString(NewTagID: TTagId; var error:TStringConversionError):String;
begin
  Result := Self.StrParser.VariantToStreamString(NewTagID, error);
end;

(*
ASCII_GROUP_SEPARATOR = #29; //For tags
ASCII_RECORD_SEPARATOR = #30; //For records
ASCII_UNIT_SEPARATOR = #31; //For individual items

function TTag.ToString:UTF8String;
var
    error_SCE:TStringConversionError;
begin
  error_sce:=SCE_ClearError;
  Result:= ASCII_GROUP_SEPARATOR + VariantToStreamString(self.tagname,error_SCE);
  Result:= Result + ASCII_UNIT_SEPARATOR + VariantToStreamString(self.TagId,error_SCE);
  Result:= Result + ASCII_UNIT_SEPARATOR + VariantToStreamString(self.Value,error_SCE);
  if not(SCE_NoError(error_SCE)) then Result:= 'Error:' + SCE_ToString( error_SCE);
end;
*)

function TTag.ToStr:UTF8String;
var
    namestr, idstr,valstr, TypeStr:UTF8String;
    separator:char;
    error:TStringConversionError;
begin
  Result:='';
  error := SCE_ClearError;
  namestr:= TagStrToStreamString(self.TagName,error);
  if Not (SCE_NoErrors(error)) then exit('Tagname?'); //Error code is set conversion above
  idstr  := TagIdToStreamString(Self.tagid,error);
  if Not (SCE_NoErrors(error)) then exit('TagId?'); //Error code is set conversion above
  valstr := StrParser.VariantToStreamString(Self.value, error);
  if Not (SCE_NoErrors(error)) then exit('TagValue?'); //Error code is set conversion above
  Typestr := StrParser.VariantToStreamString(Self.TagType, error);
  if Not (SCE_NoErrors(error)) then exit('TagType?'); //Error code is set conversion above
  Result := ASCII_GROUP_SEPARATOR + TypeStr + ASCII_UNIT_SEPARATOR +
                                    namestr + ASCII_UNIT_SEPARATOR +
                                    idstr   + ASCII_UNIT_SEPARATOR +
                                    valstr  + ASCII_DEVICE_CONTROL_2; //Device control 2 := end of tag
  writeln('ToStr result="', result, '"');
end;

Function TTag.FromStr(InputStr:Utf8String):TStringConversionError;

  function FindCharInString(str:TTagString; ch:UTF8Char; start:integer):integer;
  begin
    if (str = '') or (ch = '') then
    begin

      {$ifdef DEBUG}
      write('str or CH empty!');
      {$endif}

      exit(-1);
    end;

    Result:=pos(ch, str,start);
    {$ifdef DEBUG}
      if Result <=0 then
        writeln('not found: <',IntToHex(uint8(ch),2), '> in "',StringDumpToHex(str) ,'" ');
    {$endif}

  end;

  function FindNextTag(str:TTagString; var IdxPos:integer; var IdxTag:integer; ch:WideChar):boolean;
  begin
    idxPos := FindCharInString(InputStr, ch, idxpos);
    IdxTag := IdxPos;
    if IdxPos >0 then
    begin
      Result:=True;
      idxPos += 1;
      {$ifdef DEBUG}
      write('Tag item found. idxpos=', idxpos);
      {$endif};
    end
    else
    begin
      Result:=False;
      {$ifdef DEBUG}
      write('Tag item not found! idxpos=', idxpos)
      {$endif};
    end;
  end;

  function StrCut(inputstr:WideString; idx1, idx2:integer):STring;
  begin
    Result:=copy(InputStr, idx1 + 1, (idx2 - idx1 -1));
  end;

var

    IdxPos,
    IdxStart,
    IdxTagNameStop,
    IdxTagIdStop,
    IdxTagValueStop,
    IdxTagTypestop:integer;
    TagNameStr,
    TagIdStr,
    TagValueStr,
    TagTypeStr:UTF8String;
    VarTupple:TVariantTupple;
    error:TStringConversionError;
    vtest:Variant;
begin

  Result:= SCE_ClearError;
  IdxPos := 1;
  error := SCE_ClearError;
  error.ConvError:=SCE_syntax_error;
  //InputStr:= UTF8Decode(InputStr);

  if not findNextTag(InputStr, IdxPos, IdxStart, ASCII_GROUP_SEPARATOR) then exit(error);
  if not findNextTag(InputStr, IdxPos, IdxTagTypestop, ASCII_UNIT_SEPARATOR) then exit(error);
  if not findNextTag(InputStr, IdxPos, IdxTagNameStop, ASCII_UNIT_SEPARATOR) then exit(error);
  if not findNextTag(InputStr, IdxPos, IdxTagIdStop, ASCII_UNIT_SEPARATOR) then exit(error);
  if not findNextTag(InputStr, IdxPos, IdxTagValueStop, ASCII_DEVICE_CONTROL_2) then exit(error);

  {$ifdef DEBUG}
    writeln('InputStr ="',InputStr ,'" = "', StringDumpToHex(InputStr) ,'" ');
    writeln('Found:', IdxStart,', ', IdxTagNameStop,', ',IdxTagIdStop,', ',IdxTagValueStop,', ',IdxTagTypestop);
  {$endif}
  TagTypeStr := StrCut(InputStr, IdxStart, IdxTagTypestop);
  TagNameStr := StrCut(InputStr, IdxTagTypestop, IdxTagNameStop);
  TagIdStr   := StrCut(InputStr, IdxTagNameStop, IdxTagIdStop);
  TagValueStr:= StrCut(InputStr, IdxTagIdStop, IdxTagValueStop);
  {$ifdef DEBUG}
    writeln('TagTypeStr ="', TagTypeStr,'" = "', StringDumpToHex(TagTypeStr) ,'" ');
    writeln('TagNameStr ="',TagNameStr ,'" = "', StringDumpToHex(TagNameStr) ,'" ');
    writeln('TagIdStr ="',TagIdStr ,'" = "', StringDumpToHex(TagIdStr) ,'" ');
    writeln('TagValueStr ="', TagValueStr,'" = "', StringDumpToHex(TagValueStr) ,'" ');
  {$endif}
  vtest:= StrParser.StreamStringToVariant(TagNameStr, vt_olestr, error);
  if not SCE_NoErrors(error) then
  begin
    writeln('*** Name type error.');
    error.ConvError:=SCE_Wrong_Type;
    writeln('"', VarTupple.value,'"');
    exit(error);

  end;
  self.TagName:= vtest;
end;

constructor TTag.Create(Tag:TTagString; Id:integer; NewValue:variant; NewTagType:TTagType);
begin
  self.tagname:=Tag;
  self.tagid:=Id;
  self.value:=NewValue;
  self.TagType:=NewTagType;
  self.StrParser := TStreamStringParser.Create;
end;


Destructor TTag.Destroy;
begin
  self.StrParser.Destroy;

end;

/// Tagslist are a simple global list of tags.
constructor TTagsList.Create;
begin
  inherited;  // Call the parent Create method
  //insert your code here
  TagList:=TList.Create;
end;

destructor TTagsList.Destroy;
var
  j:integer;
Begin
  for j := 0 to TagList.Count - 1 do
  begin
    { use type-casting to free each item }
    TTag(TagList.Items [j]).Free;
  end;
  FreeAndNil(TagList);
  inherited; //We call the inherited destructor after our own
end;

function TTagsList.FindTag (findname:string):TTagId;
var
  foundit:integer;
  j:integer;
begin
  foundit:=-2;
  if assigned(TagList ) then
  begin
    foundit:=FINDERROR_DID_NOT_FIND;
    if  TagList.Count>0 then
    Begin
      for j := 0 to TagList.Count - 1 do
      begin
        { use type-casting to read each item }
        if (UpperCase(TTag(TagList.Items [j]).tagname) =UpperCase(findname)) then
        begin
          foundit:=j; //TTag(TagList.Items [j]).tagid;
        end;
      end;
    end;
  end;
  FindTag:=foundit;
end;

//function TTagsList.FindTagid (findname:string):integer;
//var
//  foundit:integer;
//  j:integer;
//begin
//
//  j:=findtag(findname);
//  if (j>=0) then
//  begin
//    foundit:=TTag(TagList.Items [j]).tagid;
//  end
//  else
//  begin
//    foundit:=j;
//  end;
//  findtagid:=foundit;
//end;

function TTagsList.FindTagId (findid:TTagId):TTagId;
var
  foundit:integer;
  j:integer;
begin
  foundit:=-2;
  if assigned(TagList ) then
  begin
    foundit:=FINDERROR_DID_NOT_FIND;
    if  TagList.Count>0 then
    Begin
      for j := 0 to TagList.Count - 1 do
      begin
        { use type-casting to read each item }
        if ((TTag(TagList.Items [j]).tagid) =findid) then
        begin
          foundit:=j;
        end;
      end;
    end;
  end;
  FindTagid:=foundit;
end;

function TTagsList.Reset_for_enumerate:TTagId;
begin
  if assigned(TagList ) then
  begin
    if  TagList.Count>0 then Result:=TagList.Count else Result:=0;
    self.current_idx:=0;
  end
  else
  begin
    self.current_idx:=-1;
    Result:=-1;
  end;
end;

function TTagsList.Enumerate_tag(var errors:integer):TTag;
begin
  errors:=0;
  if self.current_idx >= 0 then
  begin
    if assigned(TagList ) then
    begin
      if self.current_idx < (TagList.Count - 1) then
      begin
        Result:=TTag(TagList.Items [self.current_idx]);
        self.current_idx += 1;
      end;
    end
    else
    begin
      errors:=-1;
      self.current_idx:=-1;
    end;
  end;
end;


function TTagsList.AddTag(name:TTagString; id:TTagId; newvalue:variant; NewTagType:TTagType):TTagId;
begin
  //If item does not exist, then we can add item to taglist
  if (findtag(name)<0) AND (findtagid(id)<0) then
  begin
    TagList.Add (TTag.Create(name,id,newvalue, NewTagType));
    addtag:=TagList.Count - 1;
  end
  else
  begin
    addtag:=ADDERROR_ITEM_ALREADY_EXISTS;
  end;
end;

function TTagsList.RemoveTag(name:TTagString):TTagId;
var
  j:integer;

begin
  j:= findtag(name);
  if (j > -1) then
  begin
    TTag(TagList.Items [j]).Free;
    removetag:=TagList.Remove(TagList.Items [j]);
  end
  else
  begin
    removetag:=-1;
  end;
end;

function TTagsList.GetTag(id:TTagId):TTag;
begin
  if (id>=0) and (id <= (TagList.Count - 1)) then
  begin
    GetTag:= TTag(Taglist.Items [id]);
  end
  else
  begin
    GetTag:= NIL;
  end;
end;

end.

