unit StringStreamer;
/// @file:StringConverter.pas
/// @short converts variants and tagged items into strings that may be used for streams
/// @author Uffe Jakobsen
/// @version $ver$


{$mode objfpc}{$H+}{$Macro On}{$modeswitch advancedrecords}

{$ifopt D+}{$define DEBUG}{$endif}


{$ifdef DEBUG}
{$define DEBUGLVL:=1}
//{$define DEBUGLVL:=2}
//{$define DEBUGLVL:=3}
//{$define DEBUGLVL:=4}
{$else}
{$define DEBUGLVL:=0}
{$endif}

//@todo: add handling of tags by reading and writing to values as a tag with a value (done, needs substantial checking and improved unit test)
//@todo: maybe add handling of records with pointers.
//@todo: maybe add Reed-Solomon codes for redundancy (example: "Reed-Solomon Jave source")

interface


uses
    classes,
    sysutils,
{$ifdef DEBUG}
    loggerV2,
{$endif}
    math, //for type conversion
    variants, //uses Variants to store data read from stream
    fpwidestring, //Support for string to string conversion
    dateutils,  //support for consistent date <-> string conversion
    //tagslist,   //Support for tags
    crc , //CRC32 used for checksum
    results, //Resultpattern generic code
    StringConverters,
    StringConversionErrorsUnit
    ;

  //Contnrs; //objectlists

  {$ifdef DEBUG}
  {$define PRINTLVL := PRINTLEVEL_WARNING}
  {$endif}

const
  single_error_tolerance = 1e-6;
  double_error_tolerance = 1e-9;

const
  TT_Undefined           =       0; ///< A tag is not properly defined (from fileread (the reader will recover as much data as possible)
  TT_GlobalHeader        =       1; ///< A global definition. This has to be at the start of a file. All later global tags are ignored after the first TTagType of any other type..
  TT_FormHeader          =       2; ///< A form is a collection of records (TT_tems defined immediatley after are considered local variables for the form and records within the form
  TT_Item                =       3; ///< A single item is a tag as part of something larger e.g. a record
  TT_RecordHeader        =       4; ///< A start of a record. Value is the type name for the record type, TagId is an autogenerated replacement for the pointer to the record
  TT_Recordpointer_ref   =       5; ///< A reference to pointer to a record (only pointer to records are allowed now)
  TT_Formpointer_ref     =       6; ///< A reference to pointer to a form (only pointer to records are supported for now)
  TT_Globalpointer_ref   =       7; ///< A reference to pointer to a Global (only pointer to records are supported now)
  TT_GlobalItem          =       8; ///< Item used globally for the entire file
  TT_FormItem            =       9; ///< Item used globally for a form (a form is a group of records (with items))
  TT_ArrayStart          =      10;
  TT_GlobalEnd           = 128 + 1; ///< End of global header
  TT_FormEnd             = 128 + 2; ///< End of form
  TT_ItemEnd             = 128 + 3; ///< End of complex item (Not used)
  TT_RecordEnd           = 128 + 4; ///< End of record
  TT_ArrayEnd            = 128 +10;
  TT_Error               = 254;     ///< error tag
  TT_extension           = 255;     ///< Possible extension for future use

  STS_CHKSZ_BASE  = $20; // = #32 = space
  STS_CHKSZ_16    = $0;
  STS_CHKSZ_32    = $1;
  STS_CHKSZ_64    = $2;
  STS_CHKSZ_128   = $3;
  STS_CHKSZ_PAYLOAD_MASK = $3;
  STS_CHKSZ_PAYLOAD_16   = $0;
  STS_CHKSZ_PAYLOAD_32   = $1;
  STS_CHKSZ_PAYLOAD_64   = $2;
  STS_CHKSZ_PAYLOAD_128  = $3;
  STS_CHKSZ_HEADER_MASK  = $C;
  STS_CHKSZ_HEADER_16    = $0;
  STS_CHKSZ_HEADER_32    = $4;
  STS_CHKSZ_HEADER_64    = $8;
  STS_CHKSZ_HEADER_128   = $C;

type
  TTagtypeSet = Uint8;


  TTagId_large = Uint64;
  TTagUserType_large = Uint16;
  TTagIndex_large = Uint64;

  TTagId = TTagId_large ;
  TTagUserType = TTagUserType_large;
  TTagIndex = TTagIndex_large;

  p_TTagData = ^TTagData;
  TTagData = Record
    TagsId          : TTagId; //individual item in file has a unique ID
    TagsUserType    : TTagUserType; //What type is this item
    TagAbstractType : TTagtypeSet; //What part of the filestructure does this part belong to? See TTagtypeSet
    Value           : variant; //Actual value stored
//    RecPtr          : Pointer;//Used only for storing pointers to the beginning of a record/Form/Global
    //Index          : TTagIndex; //Used only for storing index of the stored record/Form/Global in a variable array
  end;
  TTagData_large = TTagData;


  TTagSizeStruct = Record
    TagSize:      Char;
    IdSize:       uint16;
    UserTypeSize: uint16;
    MetaTypeSize: uint16;
  end;

  TTagArray = array of TTagdata;
  TVariantArray = array of variant;  ///> Variable sized array of variants

  f32 = single;  //To unify with Int32/Int64 types
  f64 = double;

const
  STRID_varempty 	='E' ;
  STRID_varnull 	='N' ;
//{$ifndef FPUNONE}
  STRID_varsingle 	='s' ;
  STRID_vardouble 	='d' ;
  STRID_vardate 	='D' ;
//{$endif}
  STRID_varcurrency 	='M' ;
  STRID_varolestr 	='O' ;
  STRID_vardispatch 	='o' ;
  STRID_varerror 	='e' ;
  STRID_varboolean 	='T' ;
  STRID_varvariant 	='V' ;
  STRID_varunknown 	='?' ;
  STRID_vardecimal 	='c' ;
  STRID_varshortint 	='b' ;
  STRID_varbyte 	='B' ;
  STRID_varsmallint 	='w' ;
  STRID_varword 	='W' ;
  STRID_varinteger 	='l' ;
  STRID_varlongword 	='L' ;
  STRID_varint64 	='q' ;
  STRID_varqword 	='Q' ;
  STRID_ByteArray 	='A' ;
  STRID_ByteArrayContinued ='a' ;
  STRID_varstring 	='S' ;
  STRID_varUTF16 	='U' ;
  STRID_varUTF8 	='8' ;
  STRID_VarShortString 	='u' ;
  STRID_varCRC32 	='f' ;
  STRID_varCRC64 	='F' ;
  STRID_VarInjectedHeader = 'I';

  InjectId_Tag_Nano     ='a' ; //TTagData Injected into header (note max size for injected data=254 bytes)
  InjectId_Tag_Micro    ='b' ; //TTagData Injected into header (note max size for injected data=254 bytes)
  InjectId_Tag_Small    ='c' ; //TTagData Injected into header (note max size for injected data=254 bytes)
  InjectId_Tag_Medium1  ='d' ; //TTagData Injected into header (note max size for injected data=254 bytes)
  InjectId_Tag_Medium2  ='e' ; //TTagData Injected into header (note max size for injected data=254 bytes)
  InjectId_Tag_Large    ='f' ; //TTagData Injected into header (note max size for injected data=254 bytes)


  // InjectedIdChars contains all known character types
  InjectedIdChars = InjectId_Tag_Nano + InjectId_Tag_Micro + InjectId_Tag_Small + InjectId_Tag_Medium1 + InjectId_Tag_Medium2 + InjectId_Tag_Large; //currently only one known allowed type of injectedHeader
  // InjectedIdChars contains known character types for tagged inejctions
  InjectedIdTaggedChars = InjectId_Tag_Nano + InjectId_Tag_Micro + InjectId_Tag_Small + InjectId_Tag_Medium1 + InjectId_Tag_Medium2 + InjectId_Tag_Large; //currently only one known allowed type of injectedHeader

//----------------------------------------------

  InjectedHeaderSize = 1; //One byte for injected headers
  InjectedHeaderSizeInChars = InjectedHeaderSize * 2; //hex numbers per byte


  HexChars0Bit  = 0;
  HexChars8Bit  = 2;
  HexChars16Bit = 4;
  HexChars32Bit = 8;
  HexChars64Bit = 16;

  TTagSizeNano = InjectId_Tag_Nano;   //TagsId:Uint16, TagsUserType:<none> = 0, TagAbstractType:<none> = 0
  TTagSizeMicro = InjectId_Tag_Micro;   //TagsId:Uint16, TagsUserType:<none>=0, TagAbstractType:uint8
  TTagSizeSmall = InjectId_Tag_Small;   //TagsId:Uint16, TagsUserType:uint8, TagAbstractType:uint8
  TTagSizeMedium1 = InjectId_Tag_Medium1; //TagsId:Uint32, TagsUserType:uint8, TagAbstractType:uint8
  TTagSizeMEdium2 = InjectId_Tag_Medium2; //TagsId:Uint32, TagsUserType:uint16, TagAbstractType:uint8
  TTagSizeLarge = InjectId_Tag_Large;   //TagsId:Uint32, TagsUserType:uint16, TagAbstractType:uint8

  MAxValue8Bit  = 255;
  MaxValue16Bit = 65535;
  MaxValue32Bit = 4294967295;

  TagSizeNano    : TTagSizeStruct = ( TagSize: TTagSizeNano;
                                      IdSize: HexChars16Bit;
                                      UserTypeSize: HexChars0Bit;
                                      MetaTypeSize:HexChars0Bit);
  TagSizeMicro    : TTagSizeStruct = ( TagSize: TTagSizeMicro;
                                      IdSize: HexChars16Bit;
                                      UserTypeSize: HexChars0Bit;
                                      MetaTypeSize:HexChars8Bit);
  TagSizeSmall   : TTagSizeStruct = ( TagSize: TTagSizeSmall;
                                      IdSize: HexChars16Bit;
                                      UserTypeSize: HexChars8Bit;
                                      MetaTypeSize:HexChars8Bit);
  TagSizeMedium1 : TTagSizeStruct = ( TagSize: TTagSizeMedium1;
                                      IdSize: HexChars32Bit;
                                      UserTypeSize: HexChars8Bit;
                                      MetaTypeSize:HexChars8Bit);
  TagSizeMedium2 : TTagSizeStruct = ( TagSize: TTagSizeMEdium2;
                                      IdSize: HexChars32Bit;
                                      UserTypeSize: HexChars16Bit;
                                      MetaTypeSize:HexChars8Bit);
  TagSizeLarge   : TTagSizeStruct = ( TagSize: TTagSizeLarge ;
                                      IdSize: HexChars64Bit;
                                      UserTypeSize: HexChars16Bit;
                                      MetaTypeSize:HexChars8Bit);

  //TagDefault : TTagData = (TagsId : 0; TagsUserType :0 ; TagAbstractType: 0); //We cannot define values since :" Error: typed constants of classes or interfaces are not allowed "
//    TTagData = Record
//    TagsId          : TTagId; //individual item in file has a unique ID
//    TagsUserType    : TTagUserType; //What type is this item
//    TagAbstractType : TTagtypeSet; //What part of the filestructure does this part belong to? See TTagtypeSet
//    Value           : variant; //Actual value stored
////    RecPtr          : Pointer;//Used only for storing pointers to the beginning of a record/Form/Global
//    //Index          : TTagIndex; //Used only for storing index of the stored record/Form/Global in a variable array
//  end;


const
  varshortstring = $110;


  //Support for widestrings (converts into UTF8)
  myvarUTF8Str = 4095;
  myvarTag = 4096;
 // $f8 to $FF are not used in UTF-8: [$F8,$F9,$FA,$FB,$FC,$FD,$FE,$FF]
  ASCII_NULL = #0; //Used as escape char
  ASCII_START_OF_HEADING = #1;
  ASCII_START_OF_TEXT = #2;
  ASCII_END_OF_TEXT = #3;
  ASCII_END_OF_TRANSMISSION = #4;
  ASCII_ENQUIRY = #5;
  ASCII_ACKNOWLEDGE = #6;
  ASCII_BELL = #7;
  ASCII_BACKSPACE = #8;
  ASCII_HORISONTAL_TAB = #9;
  ASCII_LINEFEED = #10;
  ASCII_VERTICAL_TAB = #11;
  ASCII_FORMFEED = #12;
  ASCII_CARRIAGE_RETURN = #13;
  ASCII_SHIFT_OUT = #14;
  ASCII_SHIFT_IN = #15;
  ASCII_DATALINK_ESCAPE = #16;
  ASCII_DEVICE_CONTROL_1 = #17;
  ASCII_DEVICE_CONTROL_2 = #18;
  ASCII_DEVICE_CONTROL_3 = #19;
  ASCII_DEVICE_CONTROL_4 = #20;
  ASCII_NEGATIVE_ACKNOWLEDGE = #21;
  ASCII_SYNCHRONOUS_IDLE = #22;
  ASCII_END_OF_TRANSMISSION_BLOCK = #23;
  ASCII_CANCEL = #24;
  ASCII_END_OF_MEDIUM = #25;
  ASCII_SUBSTITUTE = #26;
  ASCII_ESCAPE = #27;
  ASCII_FILE_SEPARATOR = #28;
  ASCII_GROUP_SEPARATOR = #29;
  ASCII_RECORD_SEPARATOR = #30;
  ASCII_UNIT_SEPARATOR = #31;
  UTF8_UNUSED_1 = #$F8;
  UTF8_UNUSED_2 = #$F9;
  UTF8_UNUSED_3 = #$FA;
  UTF8_UNUSED_4 = #$FB;
  UTF8_UNUSED_5 = #$FC;
  UTF8_UNUSED_6 = #$FD;
  UTF8_UNUSED_7 = #$FE;
  UTF8_UNUSED_8 = #$FF;

  //ECS_ESCAPECHAR = UTF8_UNUSED1; // ASCII_NULL;
  //ECS_SYNCCHAR = UTF8_UNUSED2; // ASCII_UNIT_SEPARATOR;
  ECS_ESCAPECHAR = ASCII_NULL;
  ECS_STRING_ESCAPECHAR = ASCII_SUBSTITUTE;
  ECS_SYNCCHAR = ASCII_UNIT_SEPARATOR;
  ECS_LINEENDING = ASCII_LINEFEED;
  ECS_ESCAPECHAR_ALIAS = ASCII_DEVICE_CONTROL_1;
  ECS_SYNCCHAR_ALIAS = ASCII_DEVICE_CONTROL_2;
  ECS_CARRIAGE_RETURN_ALIAS = ASCII_DEVICE_CONTROL_3;
  ECS_LINEFEED_ALIAS = ASCII_DEVICE_CONTROL_4;

  STREAMSTRING_SYNC = ECS_ESCAPECHAR + ECS_SYNCCHAR;
  TAG_SYNC = ECS_ESCAPECHAR + ASCII_GROUP_SEPARATOR;
  RECORD_SYNC = ECS_ESCAPECHAR + ASCII_RECORD_SEPARATOR;

//type
//     TTagtypeSet =  (
//     TT_Undefined           =       0, ///< A tag is not properly defined (from fileread (the reader will recover as much data as possible)
//     TT_GlobalHeader        =       1, ///< A global definition. This has to be at the start of a file. All later global tags are ignored after the first TTagType of any other type..
//     TT_FormHeader          =       2, ///< A form is a collection of records (TT_tems defined immediatley after are considered local variables for the form and records within the form
//     TT_Item                =       3, ///< A single item is a tag as part of something larger e.g. a record
//     TT_RecordHeader        =       4, ///< A start of a record. Value is the type name for the record type, TagId is an autogenerated replacement for the pointer to the record
//     TT_Recordpointer_ref   =       5, ///< A reference to pointer to a record (only pointer to records are allowed now)
//     TT_Formpointer_ref     =       6, ///< A reference to pointer to a form (only pointer to records are supported for now)
//     TT_Globalpointer_ref   =       7, ///< A reference to pointer to a Global (only pointer to records are supported now)
//     TT_GlobalItem          =       8, ///< Item used globally for the entire file
//     TT_FormItem            =       9, ///< Item used globally for a form (a form is a group of records (with items))
//     TT_GlobalEnd           = 128 + 1, ///< End of global header
//     TT_FormEnd             = 128 + 2, ///< End of form
//     TT_ItemEnd             = 128 + 3, ///< End of complex item (Not used)
//     TT_RecordEnd           = 128 + 4, ///< End of record
//     TT_Error               = 254,     ///< error tag
//     TT_extension           = 255      ///< Possible extension for future use
//               );
const

  //TTagData_Default: TTagData = ( TagsId          : 0;
  //                               TagsUserType    : 0;
  //                               TagAbstractType : TT_GlobalItem;
  //                               Value           : real(#38) );
  //

  HEADER_CHECKSUM_SIZE_BIT   = 16;
  HEADER_CHECKSUM_SIZE_BYTES = HEADER_CHECKSUM_SIZE_BIT DIV 8; //32bit -> 4 bytes / 64bit -> 8 bytes
  HEADER_CHECKSUM_SIZE_HEX   = HEADER_CHECKSUM_SIZE_BIT DIV 4; //32bit -> 8 hexchars / 64bit -> 16 hexchars

  CHECKSUM_SIZE_BIT   = 64;
  CHECKSUM_SIZE_BYTES = CHECKSUM_SIZE_BIT DIV 8; //32bit -> 4 bytes / 64bit -> 8 bytes
  CHECKSUM_SIZE_HEX   = CHECKSUM_SIZE_BIT DIV 4; //32bit -> 8 hexchars / 64bit -> 16 hexchars


  //TagInjectedIdSize_small       = SizeOf(TTagId_small)*HEX_CHARS_PER_BYTE;
  //TagInjectedUserTypeSize_small = SizeOf(TTagUserType_small)*HEX_CHARS_PER_BYTE;
  //TagInjectedMetaTypeSize_small = Sizeof(TTagTypeSet_small)*HEX_CHARS_PER_BYTE;
  //
  //TagInjectedSize_small = TagInjectedIdSize_small + TagInjectedUserTypeSize_small + TagInjectedMetaTypeSize_small;


type
  TUTF8String = UTF8String; //Can represent all characters in a unicode string in a relative effective maner
  TUnicodeString = UnicodeString; //for cross-platform code (since widestring (OLEstring) may be to windows centric)


  TInjectionErrors = (
    IERR_NoError = 0,
    IERR_Unknown_ID,
    IERR_PayloadError
  );

  TCRC_type =  (Use16BitCRC, Use32BitCRC, Use64BitCRC, Use128BitCRC, InvalidCRCType);


  TVariantStrTupple = Record
    str:UTF8string;
    var_type:integer;
  end;

  TvartypeSet =  (
    vt_empty=varempty,      //
    vt_null=varnull,       //
    vt_int16=varsmallint,      //
    {$ifndef FPUNONE}
    vt_single=varsingle,     //
    vt_double=vardouble,     //
    {$endif}
    vt_currency=varcurrency,   //
    {$ifndef FPUNONE}
    vt_date=vardate,       //
    {$endif}
    vt_olestr=varolestr,     // WideString or Unicodestring
    vt_TwoCharString = varolestr,  //
    vt_dispatch=vardispatch,   //
    vt_error=varerror,      //
    vt_boolean=varboolean,    //
    vt_variant=varvariant,    //
    vt_unknown=varunknown,    //
    vt_decimal=vardecimal,    //
    vt_int8=varshortint,       //
    vt_uint8=varbyte,      //
    vt_uint16=varword,     //
    vt_int32=varlongword,      //
    vt_uint32,     //
    vt_int64=varqword,      //
    vt_uint64,
    vt_string = varstring, //
    vt_shortstring = varshortstring
    );

  TVariantTupple = Record
    ID: TvartypeSet;
    value:variant;
  end;


  //TResUTF8String = specialize TGenResult<UTF8String, TStringConvError>;
  TResUTF8String = specialize TGenResult<TUTF8String, TStringConvError>;
  TResUnicodeString = specialize TGenResult<TUnicodeString, TStringConvError>;
  TResVariant = specialize TGenResult<variant, TStringConvError>;
  TResVariantTupple = specialize TGenResult<TVariantTupple, TStringConvError>;
  TResVariantStrTupple = specialize TGenResult<TVariantStrTupple, TStringConvError>;
  TResTagData = specialize TGenResult<TTagData, TStringConvError>;

  //unisgned integer Result from val and potential errorpostion as integer
  TResValUint8 = specialize TGenResult<Uint8, TStringConvError>;
  TResValUint16 = specialize TGenResult<Uint16, TStringConvError>;
  TResValUint32 = specialize TGenResult<Uint32, TStringConvError>;
  TResValUint64 = specialize TGenResult<Uint64, TStringConvError>;
  TResValint8 = specialize TGenResult<int8, TStringConvError>;
  TResValint16 = specialize TGenResult<int16, TStringConvError>;
  TResValint32 = specialize TGenResult<int32, TStringConvError>;
  TResValint64 = specialize TGenResult<int64, TStringConvError>;
  TResValFloat = specialize TGenResult<Single, TStringConvError>;
  TResValDouble = specialize TGenResult<Double, TStringConvError>;
  TResValSingle = specialize TGenResult<Single, TStringConvError>;
  TResValTDateTime = specialize TGenResult<TDateTime, TStringConvError>;
  TResValBoolean = specialize TGenResult<Boolean, TStringConvError>;
  TResValCurrency = specialize TGenResult<Currency, TStringConvError>;

(* ****************** record helpers *******************

Remark Support for record helpers requires the use of Delphi mode or the use of a
advancedrecords modeswitch in other modes:
{$MODESWITCH ADVANCEDRECORDS}


type
  TTest = record
    function Test(aRecurse: Boolean): Integer;
  end;

  TTestHelper = record helper for TTest
    function Test(aRecurse: Boolean): Integer;
  end;

function TTest.Test(aRecurse: Boolean): Integer;
begin
  Result := 1;
end;

function TTestHelper.Test(aRecurse: Boolean): Integer;
begin
  if aRecurse then
    Result := inherited Test(False)
  else
    Result := 2;
end;

********************  ----------- ****************** *)

(******************* type helpers *******************
 Remark Support for type helpers requires the use of Delphi mode or the use of a
 typehelpers modeswitch in other modes:

 {$MODESWITCH TYPEHELPERS}



{$mode objfpc}
{$modeswitch typehelpers}

type

 TLongIntHelper = type helper for LongInt
   constructor create(AValue: LongInt);
   class procedure Test; static;
   procedure DoPrint;
 end;


constructor TLongIntHelper.create(AValue: LongInt);
begin
  Self:=Avalue;
  DoPrint;
end;

class procedure TLongIntHelper.Test;
begin
   Writeln('Test');
end;

procedure TLongIntHelper.DoPrint;
begin
   Writeln('Value :',Self);
end;

var
  i: LongInt;

begin
  I:=123;
  i.Test;
  $12345678.Test;
  LongInt.Test;
  I:=123;
  i.DoPrint;
  $12345678.DoPrint;
end.

*)

  TVariantTuppleArray = array of TVariantTupple;

  TParseChars = Record
    escape_char,
    Quotes_Char,
    Cr_char,
    Nl_char,
    comment_char:Char;
  end;

  TParseStrings = Record
    escape_str,
    Quotes_str,
    EndLine_str,
    must_Escape_str,
    comment_str:Utf8string;
  end;


  TShortString = utf8string;

  //TTagPair = record
  //             id:TShortString;
  //             value:Variant;
  //           end;

  //stream string parser state machine
  TChar_Type = (
    CT_UNKNOWN = 0,
    CT_Esc,
    CT_Cr,
    CT_Nl,
    CT_Quote
  );

  TEscCharStates = (
    ECS_NormalState = 0,
    ECS_InEscape);

  TExtendedChar = Record
    ch:UTF8Char;
    IsChar:boolean;
    IsValid:boolean;
  end;

  TEscapeCharStream = class (Tobject)
    private
      EscapeChar : Char;
      CurrentChar : TExtendedChar;
      EscCharState: TEscCharStates;
    public
      Constructor Create(EscChar:char);
      procedure Reset;
      function ParseChar(ch:UTF8Char):TExtendedChar;
      function CharToESCStr(ch:Char; IsChar:boolean):UTF8String;
      function StringToESCStr(Str:UTF8String):UTF8String;
  end;

  TStreamstringParserState = (
    SPS_GetSync = 0, //Wait until sync is found (if sync activated)
    SPS_GetId,       //get vartype id
    SPS_GetChecksumSizes, //Get checksumsizes
    SPS_GetInjectedId,
    SPS_GetInjectedSize,
    //SPS_GetInjectedHeader,
    SPS_GetInjectedPayload,
    SPS_GetSize,     //read size of payload
    SPS_GetSeparator,//read possible separator
    SPS_GetCheckSumHeader, //Read and validate checksum for header (if checksum activated)
    SPS_GetPayload,  //payload -> variant
    SPS_GetCheckSum, //Read and validate checksum (if checksum activated)
    SPS_Done,        //a value has been successfully retrieved and wait for reset
    SPS_Error        //An error as occured and wait for reset
    );

  TStreamStringParser = class(Tobject)
    private
      InternalState : TStreamstringParserState;
      InternalError : TStringConvError;

      InternalUseSync          : boolean;
      InternalUseChecksum      : boolean;
      InternalInjectedDetected : boolean;

      HeaderChecksumSize: UInt8;
      PayloadChecksumSize: UInt8;
      ExpectedSizeSize :integer; //Expected size of size field based on ID
      counter:integer;
      ExpectedPayloadSize : UInt64; //Expected payload size based on receivedDatasize
//      ReceivedDataSize: UInt64;
      ExpectedType: TvartypeSet; //Callers Expected type (or VT_unknown)
      ReceivedType: TvartypeSet; //The found type from ID char
//      calculated_checksum:UInt64; //
      InjectedHeader,
      headerBlock,
      ChkSumSizeStr,
      sizeString,
      payloadString,
      checksumString:UTF8String;
      CheckSumSize_Header, CheckSumSize_Payload : TCRC_type;

      _payload:variant;

      SeparatorChar : UTF8String;
      ID:UTF8Char;

      StrHexSizeSize,
      OtherHexSizeSize,
      IdSize, //one char for id
      separatorSize, //one char for separator
      MinSizeSize, //two chars for min size (one byte)
      MinStrSize, //zero chars for empty string
      MinSize:UInt8;

      FirstState,
      LastState:TStreamstringParserState;


      function GetState:integer;

      function StringTuppleToVariant(const source:TVariantStrTupple):TResVariant;
//      Function ExtractFirstStreamString(source:UTF8String; var error:TStringConvError; var remainderString:Utf8String):Utf8String;
      Function GetSizeOfSizeBlock(VT:TvartypeSet):integer;
      Function GetSizeOfSizeBlock(VarTypeID:Integer):integer;
      Function GetSizeOfSizeBlock(Token:Char; var VT:TvartypeSet):integer;
      function is_done:boolean;
//      function Has_error:boolean;
      function GetSizeOfPayloadCheckSum(checksumval:uint8):TCRC_type;
      function GetSizeOfHeaderCheckSum(checksumval:uint8):TCRC_type;
    public
      EscParser : TEscapeCharStream;
      InjectedId : Char;
      InjectedSize : UInt32;
      Injected : TUTF8String;

      constructor Create;
      destructor Destroy; override;
//T   procedure SetSceError(SetError:TStringConvError);
{ TODO -ouja : Clean up error code to use new result functions. Lines marked //T are removed pending tests and rewrite (and may need to be restored if changes causes big problems) }
      procedure SetSceError(SetError:TStringConvError);
      procedure SetSceError(SetError:TStringConvError_set);
      procedure SetSceMeError(SetError:TMemoryError_set);
      property ParserState:integer read GetState;
//T   property Error:TStringConvError read InternalError write InternalError;
      property payload:variant read _payload;
      property UsesChecksum:boolean read InternalUseChecksum;
      property UsesSync:boolean read InternalUseSync;
      property IsDone:boolean read is_done;
      function HasErrors:boolean;// read InternalError.HasErrors;

      procedure ResetState;
      function ActivateChecksum:boolean;
      function ActivateSync:boolean;
      function DisableChecksum:boolean;
      function DisableSync:boolean;
      function SetCRC(active:boolean):boolean;
      function SetSync(active:boolean):boolean;

      function UpdateStateMachine(newdata: UTF8Char):TStreamstringParserState;
      function VariantToStreamString(source:TUnicodeString):TResUTF8String;
      function VariantToStreamString(source:TUTF8String):TResUTF8String;
      function VariantToStreamString(source:variant):TResUTF8String;
//      function VariantToStreamString_(source:variant):TUTF8String;
      function VariantToStreamString_(source:variant; InjectedHeader_:TUTF8String; InjectedId_:char):TResUTF8String;
//      function TagToStreamString(source:TTagData; var errors:TStringConvError):TUTF8String;
      Function StreamStringToVariant(streamstring:UTF8String; VarExpectedType:TvartypeSet):TResVariant;
      function StreamStringToVariantTupple(source:TUTF8String):TResVariantTupple;

      function InjectionHandler(PayloadId:char; InjectedPayload:TUTF8String):TInjectionErrors; virtual; abstract;
      Procedure PostParseHandler(VarValue:Variant; var ErrorCode:TStringConvError); virtual; abstract;
  end;

  TStructData = Record
    RecordPtr: Pointer;
    Stored : Boolean;
    Defined: Boolean;
    Next , Prev, Parent, Child: Uint32;
  end;



  TStreamStringParserTagSupport = class (TStreamStringParser)
    private
      RecordPointers : array of TStructData;
      RecordBracketStack: array of Uint32;
      LastId:Uint32;
    public
      TagData:TTagData;
      //procedure InitTag(var tag:TTagData);
      procedure InitTag_;

      function TagAbstractTypeToText(AbstractTagType : TTagtypeSet) :TUTF8String;
      function injectionhandler(PayloadId:char; InjectedPayload:UTF8String):TInjectionErrors; override;

      //function TagToStreamString(source:TTagData_small; var errors:TStringConvError):TUTF8String;
      //function TagToStreamString(source:TTagData_medium1; var errors:TStringConvError):TUTF8String;
      //function TagToStreamString(source:TTagData_medium2; var errors:TStringConvError):TUTF8String;
      function TagToStreamString(source:TTagData):TResUTF8String;
      function StreamStringToTaggedVariant(streamstring:UTF8String; VarExpectedType:TvartypeSet):TResTagData;

      function ItemToStreamString(Source:Variant):TResUTF8String;
      //function ItemToStreamString(Source:TTagData_small; var errors:TStringConvError):TUTF8String;
      //function ItemToStreamString(Source:TTagData_medium1; var errors:TStringConvError):TUTF8String;
      //function ItemToStreamString(Source:TTagData_medium2; var errors:TStringConvError):TUTF8String;
      function ItemToStreamString(Source:TTagData):TResUTF8String;

      procedure StreamStringToItem(streamstring:UTF8String; VarExpectedType:TvartypeSet; var dest:TResTagData);
      procedure StreamStringToItem(streamstring:UTF8String; VarExpectedType:TvartypeSet; var dest:TResVariant);

      Procedure PostParseHandler(VarValue:Variant; var ErrorCode:TStringConvError); override;
//{ #todo : ide er måske at gemme alle pointere i et array og kun bruge idx til at refere til arrays, men lade bruger gemme pointere i array }
//      Function AllocRecord(ReceivedUserType:Uint16; RecordId:uint32; Idx:uint32; RecordLabel:variant):Uint32; virtual; abstract;
//      procedure ProcessItem(tag:TTagData; var errors:TStringConvError); virtual; Abstract;
//      Function PostProcessRecord(FormId, RecordId : uint32; ReceivedUserType:Uint16; RecievedAbstractType:uint8; value: variant; var errors:TStringConvError):boolean; virtual; abstract;

      procedure ResetIdCounter;
      Function GetNextID:Uint32;
  end;

  //const
  //  x1 = soBeginning;
  //  x2 = soCurrent;
  //  x3 = soEnd;

  TStreamStringHandler = class (TStreamStringParserTagSupport)
    Private

      StreamUse, ReadOpen, WriteOpen :Boolean;
      _CurrentStream:TFileStream;
      CurrentStreamName:UTF8String;

      //_filestream : TFileStream;
      //_memstream  : TMemoryStream;
      //_filehandle:TextFile;
      function ReadVariantTupplefromStream(AStream:TStream):TResVariantTupple;
//      function _IsFileOpen:boolean;
      function _IsStreamOpen:boolean;
      function OpenStreamForRead( filename:TUTF8String):boolean;
      function OpenStreamForWrite( filename:TUTF8String; NewFile:boolean):boolean;
      procedure CloseStream;
      function GetStreamSize:int64;
      function StreamSeek(offset: int64; Origin:TSeekOrigin):int64;
      property OpenForRead:boolean read ReadOpen;
      property OpenForWrite:Boolean read WriteOpen;
      property UseStream:boolean read StreamUse write StreamUse;
//      property IsFileOpen:boolean read _IsFileOpen;
      property IsStreamOpen:boolean read _IsStreamOpen;
      //function ParseString(Source:TUTF8String;Var Value:TTagData_small; var FoundItem:boolean; Var ErrorCode:TStringConvError):TUTF8String;
      //function ParseString(Source:TUTF8String;Var Value:TTagData_medium1; var FoundItem:boolean; Var ErrorCode:TStringConvError):TUTF8String;
      //function ParseString(Source:TUTF8String;Var Value:TTagData_medium2; var FoundItem:boolean; Var ErrorCode:TStringConvError):TUTF8String;
    Public

      constructor Create;
      Destructor Destroy; override;

      //opdateres med indpakningsfunktion der klarer både variant og TTagData og
      function ParseString(Source:TUTF8String;Var Value:TTagData; var FoundItem:boolean):TResUTF8String;
      function ParseString(Source:TUTF8String;Var Value:Variant; var FoundItem:boolean):TResUTF8String;
      function StreamReadString(AStream:TStream; no_of_bytes:UInt32):TResUTF8String;
      function WriteStringToStream(AStream:TStream; value:TUTF8String; var ErrorCode:TStringConvError):int64;

      procedure WriteVariantToStream(AStream:TStream; source:TUnicodeString; var ErrorCode:TStringConvError);
      procedure WriteVariantToStream(AStream:TStream; source:TUTF8String; var ErrorCode:TStringConvError);
      procedure WriteVariantToStream(AStream:TStream; source:variant; var ErrorCode:TStringConvError);
      procedure WriteVariantToStream_ErrorFallThrough(AStream:TStream; source:TUnicodeString; var ErrorCode:TStringConvError);
      procedure WriteVariantToStream_ErrorFallThrough(AStream:TStream; source:TUTF8String; var ErrorCode:TStringConvError);
      procedure WriteVariantToStream_ErrorFallThrough(AStream:TStream; source:variant; var ErrorCode:TStringConvError);

      function ReadVariantFromSTream(Astream:TStream; VarexpectedType:TvartypeSet):TResVariant;
      function ReadVariantFromSTream_ErrorFallThrough(Astream:TStream; VarExpectedType:TvartypeSet;
                                     var ErrorCode:TStringConvError):TResVariant;

  end;


  TArrayObject = class( Tobject)
    private
    public
      constructor create; virtual; abstract;
      //destructor destroy; override;
      Function ToStreamString(StreamStrHandler:TStreamStringHandler):TResUTF8String; virtual; abstract;
      function FromStreamString (StreamStrHandler:TStreamStringHandler; data:TUTF8String):TResUTF8String; virtual; abstract;
      Procedure SetDefault; Virtual; Abstract;
      function ToText:TUTF8String; virtual; abstract;
  end;

  TTagObj      = class( TArrayObject )
    private
    public
      value: TTagData;
      constructor create; override;
      Function ToStreamString(StreamStrHandler:TStreamStringHandler):TResUTF8String; override;
      function FromStreamString (StreamStrHandler:TStreamStringHandler; data:TUTF8String):TResUTF8String; override;
      Procedure SetDefault; Override;
      function ToText:TUTF8String; override;
  end;

  //TTagObj     = specialize TTagObj_gen<TTagData>;
  //TTagObj_small     = specialize TTagObj_gen<TTagData_small>;
  //TTagObj_medium1     = specialize TTagObj_gen<TTagData_medium1>;
  //TTagObj_medium2     = specialize TTagObj_gen<TTagData_medium2>;


  TVariantObj     = class( TArrayObject )
    private
    public
      value:Variant;
      constructor create; override;
      Function ToStreamString(StreamStrHandler:TStreamStringHandler):TResUTF8String; override;
      function FromStreamString (StreamStrHandler:TStreamStringHandler; data:TUTF8String):TResUTF8String; override;
      Procedure SetDefault; Override;
      function ToText:TUTF8String; override;
  end;

//  generic TGenArray<T,T2> = class(TStreamStringHandler) //T is the object type containing a record of type T2
  generic TGenArray<T,T2> = class(TObject) //T is the object type containing a record of type T2
    private
      ItemsInArray_priv : integer;
      StrHandler: TStreamStringHandler;
      initialized:boolean;

      function StringToEscapedString(StringToWrite:TUTF8String):TUTF8String; //package <lf> -> <esc><lf>
      function EscapedStringToString(StringToWrite:TUTF8String):TUTF8String; //unpackage <esc><lf> -> <lf>

      function InitializeArray:boolean;
      function RecoverableError:boolean;
      function GetError:TStringConvError;
      procedure SetError(ErrorSet:TStringConvError);
      procedure SetConversionError(ErrorSet:TStringConvError_set);
      function ExpandArray:Uint32;
//      function ParseString(Source:TUTF8String;Var Value:TUTF8String; var FoundItem:boolean; Var ErrorCode:TStringConvError):TUTF8String;
      function ParseString(Source:TUTF8String;Var Value:Variant):TResUTF8String;
      function ParseString(Source:TUTF8String;Var Value:TTagData):TResUTF8String;
      function _IsReadOpen:boolean;
      function _IsWriteOpen:boolean;
    public
      FreeList : Array of Uint32; //List over free elements
      DataArray : array of T;
      property error:TStringConvError read GetError write SetError;
      property StreamOpenForRead:boolean read _IsReadOpen;
      property StreamOpenForWrite:boolean read _IsWriteOpen;

      constructor create;
      destructor destroy; override;
      Procedure ClearError;
      function ClearArray:Boolean;
      Function ItemsInArray:integer;
      function AddItem   ( newitem:T2):integer;
      function RemoveItem( idx:integer):T2;
      function ErrorToString:TUTF8String;
      function HasError:boolean;
      function NoError:boolean;


      function OpenRead(filename:TUTF8String):boolean;
      function OpenReWrite(filename:TUTF8String):boolean;
      function OpenAppend(filename:TUTF8String):Boolean;
      function CloseFile:boolean;
      function writeline(StringToWrite:TUTF8String):Boolean;
      function Readline(var StringToRead:TUTF8String):Boolean;
      function GetNext(StrData:TUTF8String):TResUTF8String;

      Function ItemToStreamString(idx_in_DataArray: uint32):TResUTF8String;
      //Function ItemToStreamString(item:Variant):TUTF8String;
      //Function ItemToStreamString(item:TTagData):TUTF8String;
      //Function ItemToStreamString(item: T):TUTF8String;  virtual; abstract;

      //Parses streamstr, if sync enabled it will discard part of string until sync is found. Remainding string that does not contain a full item is returned as the result. Received items that are full and with accepted checksum is appendd to the array
      function ArrayToStreamStr(usertype: uint16; userid:uint64):TResUTF8String;
      function StreamStrToArray(StreamStr:TUTF8String; var HeaderTag:TTagData):TResUTF8String;
  end;

  TTagObjArray     = specialize TGenArray<TTagObj, TTagData>;

  TVariantObjArray = specialize TGenArray<TVariantObj, Variant>;


{ #todo -ouja -cimprovement : change so that new types may be added with virtual functions}
  operator + (TagArr: TTagObjArray; TagDat:TTagData) : TTagObjArray;
//  operator + (TagArr: TTagObjArray; Value:Variant)   : TTagObjArray;
  function ToObj(TagDat:TTagData):TTagObj;
  function ToObj(VariantData:Variant):TVariantObj;

//operator in (Val1:UTF8String; Val2: UTF8Char): boolean;
//operator in (Val1, Val2: UTF8String): boolean;



  function CrcStr(tupple_str:TUTF8String; CRCType:TCRC_type):TUTF8String; ///< Calculates CRC32 for the string
//  function HexToInteger(hexstr:TUTF8String; var errorpos:integer):UInt64; ///< Converts hex string to integer
  function ValToUInt64(ValStr:TUTF8String):TResValUint64;
  function ValToUint32(ValStr:TUTF8String):TResValUInt32;
  function ValToUint16(ValStr:TUTF8String):TResValUInt16;
  function ValToUint8(ValStr:TUTF8String):TResValUInt8;

  function HexToUInt64(hexstr:TUTF8String):TResValUInt64;
  function HexToUInt32(hexstr:TUTF8String):TResValUInt32;
  function HexToUInt16(hexstr:TUTF8String):TResValUInt16;
  function HexToUInt8(hexstr:TUTF8String):TResValUInt8;

  function StringDumpToHex(instr:TUnicodeString):TUTF8String; ///< Dumps individual characters to as separated hex numbers in a string (for debugging mostly)
  function StringDumpToHexUTF8(instr:UTF8String):TUTF8String; ///< Dumps individual characters to as separated hex numbers in a string (for debugging mostly)
  function StringDumpToHex(instr:TUTF8String):TUTF8String; ///< Dumps individual characters to as separated hex numbers in a string (for debugging mostly)
//  procedure writechars(source:TUTF8String);
  Function TTwoCharStringToRawString(source:TUnicodeString):TUTF8String; ///< converts UTF16 string to UTF8 string representation (may be expanded with more features later)
  Function RawstringToTTwoCharString(source:TUTF8String):TUnicodeString; ///< converts UTF8 string to UTF16 string representation (may be expanded with more features later)
  function IntToString(value:LongInt):TUTF8String; ///< convinience function that converts int to string
  function FloatToString(value:double; totaldigits, decimals:integer):TUTF8String; ///< convinience function that converts float to string

  ///single_error_tolerance vs double_error_tolerance (functions for comparing floats with each other)
  function ApproxEqual(value1:Single; value2:Single):boolean; ///< single precision comparison
  function ApproxEqual(value1:Single; value2:Double):boolean; ///< single precision comparison
  function ApproxEqual(value1:Double; value2:Single):boolean; ///< single precision comparison
  function ApproxEqual(value1:Variant; value2:Double):boolean; ///< single/double precision depending on variant
  function ApproxEqual(value1:Double; value2:Variant):boolean; ///< single/double precision depending on variant
  function ApproxEqual(value1:Double; value2:Double):boolean; ///< Double precision comparison

  operator = (Val1, Val2: TTagData): boolean;
  operator <> (Val1, Val2: TTagData): boolean;
//  operator >< (Val1, Val2: TTagData): boolean;
  operator := (value:variant) tag:TTagData;
//  operator and (val1, val2: TTagData): TTagData;

  function StringConversionErrorToString(error:TStringConvError ):TUTF8String; ///< Converts errors to a descriptive string
  function SCE_ToString(error:TStringConvError ):TUTF8String;                  ///< Alias for above function
  Function SCE_ClearError:TStringConvError;                                       ///< Clears stringconversion error record
  Function SCE_NoErrors(error:TStringConvError):boolean;                          ///< True if there are no errors
  Function SCE_HasErrors(error:TStringConvError):boolean;                         ///< True if there are any errors (inverts result from above)
  function InitTag:TTagData;

//  Function UnitTest_variant_functions(var success:boolean):Boolean;
  function is_escape_sequence(preceeding, current:char; ParseChars:TParseChars):boolean; //for handling text based strings with an escape char (different from TEscapeCharStream handling of escapechars in streams)
  function ConvertEscapeSequence(indline:TUTF8String; ParseChars:TParseChars):TUTF8String;
  function remove_whitespace(indline:TUTF8String; ParseChars:TParseChars):TUTF8String;

  function Utf8String_To_EscapedUtf8String(StringToConvert:UTF8String):UTF8String;
  function EscapedUtf8String_To_Utf8String(StringToConvert:UTF8String):UTF8String;
  function test_UTF_escape_functions(ok:Boolean):boolean;

implementation

{$Macro On}{$define INFOLINE:=PRINTLVL, {$i %file%}, {$i %CURRENTROUTINE%}}


const
  SMALL_PAYLOAD_SIZE = 48; //payload less than 48 chars -> 15bit checksum, otherwise-> 32bit checksum

  variant_names : array[varEmpty..varQWord] of string[8] = (
  'Empty','Null','Smallint','Integer',
  'Single','Double','Currency','Date',
  'OleStr','Dispatch','Error','Boolean',
  'Variant','Unknown','Decimal','???',
  'ShortInt','Byte','Word','DWord',
  'Int64','QWord');
  variant_supported : array[varEmpty..varQWord] of boolean = (
//  'Empty','Null','Smallint','Integer',
  True ,True ,True ,True ,
//  'Single','Double','Currency','Date',
  True ,True ,True ,True ,
//  'OleStr','Dispatch','Error','Boolean',
  False,False,False,True ,
//  'Variant','Unknown','Decimal','???',
  False,False,True ,False,
//  'ShortInt','Byte','Word','DWord',
  True ,True ,True ,True ,
//  'Int64','QWord');
  True ,True);


  //StrHexSizeSize = 8;
  //OtherHexSizeSize = 2;
  //SEPARATORCHAR = '';
  //
  //IdSize = 1; //one char for id
  //separatorSize = 0; //one char for separator
  //MinSizeSize = 2; //two chars for min size (one byte)
  //MinStrSize = 0; //zero chars for empty string
  //MinSize = IdSize + MinSizeSize + MinStrSize;


var
  DefaultFileFormatSettings : TFormatSettings = (
    CurrencyFormat: 1;
    NegCurrFormat: 5;
    ThousandSeparator: ' ';
    DecimalSeparator: '.';
    CurrencyDecimals: 2;
    DateSeparator: '-';
    TimeSeparator: ':';
    ListSeparator: ',';
    CurrencyString: 'C';
    ShortDateFormat: 'dd/mm/yyyy';
    LongDateFormat: 'dd" "mmmm" "yyyy';
    TimeAMString: 'AM';
    TimePMString: 'PM';
    ShortTimeFormat: 'hh:nn';
    LongTimeFormat: 'hh:nn:ss';
    ShortMonthNames: ('Jan','Feb','Mar','Apr','May','Jun',
                      'Jul','Aug','Sep','Oct','Nov','Dec');
    LongMonthNames: ('January','February','March','April','May','June',
                     'July','August','September','October','November','December');
    ShortDayNames: ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
    LongDayNames:  ('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday');
    TwoDigitYearCenturyWindow: 50;
  );


//Forward declarations
//function _ExpandArray(var TagArr:TTagArray):Uint32; forward;

function VarTypeTextToType(const StrVarType: string): integer; forward;
//function StringToQword(source:string; var error:TStringConvError):QWord; forward;//uint64 alias
function StringToInt64(source:TUTF8String):TResValint64; forward;
function StringToUInt64(source:TUTF8String):TResValUint64; forward;
function StringToInt32(source:TUTF8String):TResValInt32; forward;
function StringToUInt32(source:TUTF8String):TResValUInt32; forward;
function StringToInt16(source:TUTF8String):TResValInt16; forward;
function StringToUInt16(source:TUTF8String):TResValUInt16; forward;
function StringToInt8(source:TUTF8String):TResValInt8; forward;
function StringToUInt8(source:TUTF8String):TResValUInt8; forward;
function StringToDouble(source:TUTF8String):TResValDouble; forward;
function StringToSingle(source:TUTF8String):TResValSingle; forward;
function StringToDate(source:TUTF8String):TResValTDateTime; forward; //Assumes standard encoding based on internal settings
function StringToBoolean(source:TUTF8String):TResValBoolean; forward;
function StringToCurrency(source:TUTF8String):TResValCurrency; forward; //Assumes standard encoding based on internal settings
//function StreamStringToVariantTupple(source:TUTF8String; var error:TStringConvError):TVariantTupple;  forward;
//  function ReadVariantTupplefromStream(AStream:TStream; var error:TStringConvError):TVariantTupple;  forward;
//  function StreamWriteString(AStream:TStream; Str_To_Send:AnsiString; var error:boolean ):UInt32; forward; //no of bytes sent
function Ident_to_varianttype(var_type:char):Uint16; forward;
Function VariantTypeType_to_TvartypeSet(vartype:uint16):TvartypeSet;  forward;
Function TvartypeSet_to_VariantTypeType(vartype:TvartypeSet):Uint16; forward;
function ident_to_TvartypeSet(ident:char):TvartypeSet; forward;

//generic TGenResult<ResultType, ErrorType> = record //class(Tobject)


operator := (value:TResValDouble) res:TResValSingle;
begin
  if value.SuccessOrWarning then
   if value.Success then Result.SetResult(value.Result) else Result.SetWarning(value.Result,value.Error)
  else
   if value.Failure then Result.SetFailure(value.error) else Result.SetPartialFailure(value.Result,value.Error);
end;

operator <> (Val1, Val2: TTagData): boolean;
begin
  if (val1 = val2) then Result:= False else Result:=True;
end;


operator = (Val1, Val2: TTagData): boolean;
// @short: equal operator for tags. Does not compare pointers in the tag, since ID is the only thing assured to ID a unique item.
begin
  //Compare floats approximately as single precision floats
  if ( VarIsFloat(val1.Value) and VarIsFloat(val2.Value)) then
  begin
    //write('< float cmp in "=" operator >');
    if ApproxEqual(single(val1.Value), single(val2.Value) ) And
       (val1.TagAbstractType = val2.TagAbstractType) And
       (val1.TagsId          = val2.TagsId         ) And
       (val1.TagsUserType    = val2.TagsUserType   ) then exit(True) else exit(False);
  end;
  //Compare strings directly, since this is allowed and type may be different but content is correct.
  if ( VarIsStr(val1.Value) and VarisStr(val2.value) ) then
  begin
  //write('< str cmp in "=" operator (val1 type='+ IntToString(Vartype(val1.Value))  +
  //      ') (val2 type='+ IntToString(Vartype(val1.Value))  +') >');
    if (val1.Value           = val2.Value          ) And
       (val1.TagAbstractType = val2.TagAbstractType) And
       (val1.TagsId          = val2.TagsId         ) And
       (val1.TagsUserType    = val2.TagsUserType   ) then
    begin
      //write('{"=" Match!}');
      exit(True);
    end;
    //if (val1.Value <> val2.Value ) then write ('["<>" values] ');
    //if (val1.TagAbstractType <> val2.TagAbstractType)then  write ('["<>" TagAbstractType] ');
    //if (val1.TagsId <> val2.TagsId ) then write ('["<>" TagsId] ');
    //if (val1.TagsUserType <> val2.TagsUserType   ) then write ('["<>" TagsUserType] ');
    exit(False);
  end;
  //write('< normal cmp in "=" operator >');
  //Vartype is not float, nor dstring. Types have to match now

  if VarType(val1.Value) <> VarType(val2.Value) then
  begin
    //write('[ EQU failed: val1.type=', VarType(val1.Value) , ' val2.type=',VarType(val2.Value),'] ');
    exit(false); // the two types must match as well
  end;
  //Vartype is not float, nor dstring. Types match now checks contents of tag
  if (val1.Value           = val2.Value          ) And
     (val1.TagAbstractType = val2.TagAbstractType) And
     (val1.TagsId          = val2.TagsId         ) And
     (val1.TagsUserType    = val2.TagsUserType   ) then exit(True) else exit(False);
end;

operator := (value:Variant) tag:TTagData;
begin
  Result:= InitTag;
  Result.Value:=value;
end;

//operator := (Value:TTagenericgData) _Result:TTagData;
//begin
//  Result.RecPtr:= Value.RecPtr ;
//  Result.TagAbstractType:= Value.TagAbstractType ;
//  Result.RecPtr:= Value.RecPtr ;
//  Result.RecPtr:= Value.RecPtr ;
//  Result.RecPtr:= Value.RecPtr ;
//end;

operator + (TagArr: TTagObjArray; TagDat:TTagData):TTagObjArray;
begin
  tagarr.AddItem(TagDat);
  exit(TagArr);
end;



//operator + (TagArr: TTagArray; TagDat:TTagData):TTagArray;
//const
//  MagicNr = $0CED;
//var Len1,len2:Uint64;
//begin
//  Result := TagArr;
//  Len1 := (length(Result));
//  if len1 = 0 then
//  begin
//    Len1:=_ExpandArray(TagArr);
//    {$if DEBUGLVL>=3}
//    log.LogStatus('Array init in operator "+"', INFOLINE , {$i %line%});
//    {$endif}
//
//    TagArr[0].TagAbstractType:=Uint8(TT_GlobalItem);
//    TagArr[0].TagsUserType:=MagicNr;
//    TagArr[0].Value := 0;
//    TagArr[0].TagsId:= 0;
//    TagArr[0].RecPtr:= Nil;
//  end;
//  result:=TagArr;
//
//  if TagArr[0].TagsUserType<> MagicNr then
//  begin
//    {$if DEBUGLVL>=1}
//      log.LogError('Tries to expand non initialized array in operator "+"', INFOLINE , {$i %line%});
//    {$endif}
//    exit(TagArr);
//  end;
//
//  if (Result[0].TagsId + 1) >= Len1 then //Array needs to be expanded
//  begin
////    writeln('Len1=', len1,' tagsid length =',Result[0].TagsId);
//    Len2:=_ExpandArray(Result);
//    {$if DEBUGLVL>=3}
//    log.LogStatus('Array expand with operator "+"', INFOLINE , {$i %line%});
//    {$endif}
//    if len1 = len2 then //The array did not expand!!!
//    begin
//      Result[0].TagAbstractType:=Uint8(TT_Error);
//      {$if DEBUGLVL>=1}
//      log.LogError('Could not expand array with operator "+"', INFOLINE , {$i %line%});
//      {$endif}
//      exit(Result);
//    end;
//  end;
//  inc(Result[0].TagsId);
//  Result[Result[0].TagsId]:=TagDat;
//end;

//operator + (TagArr: TTagArray; Value:Variant):TTagArray;
////Allows the addition of variants directly (useful for adding global items only!!!!)
//var
//  TagData:TTagData;
//begin
//  TagData:=InitTag;
//  TagData.value := value;
//  Result:= TagArr + TagData;
//end;


//From https://stackoverflow.com/questions/19358246/crc-ccitt-to-crc16-modbus-implementation
  //function mb_CalcCRC16(ptr: pointer to byte; ByteCount: byte): word;
  //var
  //  crc: word;
  //  b, i, n: byte;
  //begin
  //  crc := $FFFF;
  //  for i := 0 to ByteCount do
  //    if i = 0 then           // device id is 1st byte in message, and it is not in the buffer
  //      b := mb_GetMessageID; // so we have to calculate it and put it as 1st crc byte
  //    else
  //      b := ptr^;
  //      Inc(ptr);
  //    endif;
  //    crc := crc xor word(b);
  //    for n := 1 to 8 do
  //      if (crc and 1) = 1 then
  //        crc := (crc shr 1) xor $A001;
  //      else
  //        crc := crc shr 1;
  //      endif;
  //    endfor;
  //  endfor;
  //  Return(crc);
  //end;
  //
  //function mb_CalcCRC: word; // Calculate CRC for message in mb_pdu
  //begin // this message can be one that is just received, or in a reply we have just composed
  //  Return(mb_CalcCRC16(@mb_pdu[1], mb_GetEndOfData));
  //end;
  //Small PHP version
  //function crc16_ansi($data) {
  //  $crc = 0xFFFF;
  //  for ($i = 0; $i < strlen($data); $i++){
  //    $crc ^= ord($data[$i]);
  //    for($j = 8; $j--;)
  //      $crc = $crc & 0x0001 ? $crc = ($crc >> 1) ^ 0xA001 : $crc >> 1;
  //  }
  //  return $crc;
  //}
function CRC16(ptr: PUInt8; ByteCount: UInt32): UInt16; //modbus CRC
var
  crc: UInt16;
  b, i, n: UInt8;
begin
  crc := $FFFF;
  for i := 0 to ByteCount do
  begin
    b := ptr^;
    Inc(ptr);
    crc := crc xor word(b);
    for n := 1 to 8 do
      if (crc and 1) = 1 then crc := (crc shr 1) xor $A001 else crc := crc shr 1;
  end;
  result := crc;
end;

//Alternate solution:
//https://control.com/forums/threads/modbus-source-code-in-pascal-or-c.7576/

//Panu-Kristian Poiksalo
//Feb 28, 2003
//
//    #9
//
//> Do you know of some code that could do the CRC calculations for me?
//
//Hi, here's an ObjectPascal or Delphi function for generating the CRC.
//
//Have fun!
//Panu-Kristian Poiksalo

{MODBUS CRC-16 ObjectPascal (Delphi) Routine by Panu-Kristian Poiksalo 2003
This function calculates a checksum STRING for a message STRING for maximum
usability for me... example call for this function would be something like...

var message:string;
begin
message:=#1#5#0#0#255#0;
ModbusSerialPort.Output:= message + crc16string (message);
end;

happy coding! send me a greeting at bancho@microdim.net when you get it to
work and share this code freely with everyone at any web site!}

//function crc16string(msg:string):string;
//var
//  crc: word;
//  n,i: integer;
//  b:byte;
//begin
//  crc := $FFFF;
//  for i:=1 to length (msg) do begin
//    b:=ord(msg);
//    crc := crc xor b;
//    for n:=1 to 8 do begin
//      if (crc and 1)<>0 then crc:=(crc shr 1) xor $A001 else crc:=crc shr 1;
//    end;
//  end;
//  result:=chr(crc and $ff)+chr(crc shr 8);
//end;

function CrcStr(tupple_str:TUTF8String; CRCType:TCRC_type):TUTF8String;
///@short: CRC of string. Empty string returns 0
var
    CkhSumVal:UInt64;
    ChkSumVal128:u128;
    //chksum:TUTF8String;
begin
  {$if DEBUGLVL >= 4}
  write('CrcStr:"',tupple_str,'"  ');
  {$endif}
  CkhSumVal:=0;
  Result:='';
  if tupple_str <> '' then
  begin
    case CRCType of
      Use16BitCRC:
        Begin
          CkhSumVal:=crc16(@tupple_str[1],length(tupple_str));
          Result := IntToHex(CkhSumVal, 4);
        End;
      Use32BitCRC:
        begin
          CkhSumVal:=crc32(CkhSumVal,@tupple_str[1],length(tupple_str));
          Result := IntToHex(CkhSumVal, 8);
        End;
      Use64BitCRC:
        begin
          CkhSumVal:=crc64(CkhSumVal,@tupple_str[1],length(tupple_str));
          Result := IntToHex(CkhSumVal, 16);
        End;
      Use128BitCRC:
        begin
          ChkSumVal128:=crc128(CkhSumVal,@tupple_str[1],length(tupple_str));
          Result := IntToHex(ChkSumVal128.hi, 16);
          Result := Result + IntToHex(ChkSumVal128.lo, 16);
        End;
      otherwise
        Result:='Unknown CRC type = ' + IntToString(byte(CRCType))+' ';
    end;
  end;
end;


function CrcStr(UseChecksum:boolean; tupple_str:TUTF8String; CRCType:TCRC_type):TUTF8String;
//Helper function that simplifies switching CRC on/off
begin
  if UseChecksum then
  begin
    Result := CrcStr(tupple_str, CRCType);
  end
  else
  begin
    result:=''; //CRC is not needed -> return empty string -> no chars
  end;
end;

//function VariantToStringTupple(source:variant):TVariantStrTupple;
//
// function StringTuppleToVariant(const source:TVariantStrTupple; var error:boolean ):Variant;
//function GetNulVariant(expectedtype:TvartypeSet):Variant;  forward;//For return value if we cannot read or it is of incorrect type
function GetNulVariant(expectedtype:TvartypeSet):Variant; //For return value if we cannot read or it is of incorrect type
//If we fail to read parse the text string, an expected variant type is returned with a Nul value (type dependent). Date type returns Current time
const
  c_uint8  = char(#0);
  c_int8   = byte(0);
  c_uint16 = UInt16(0);
  c_int16  = Int16(0);
  c_uint32 = UInt32(0);
  c_int32  = Int32(0);
  c_uint64 = UInt64(0);
  c_int64  = Int64(0);
//    c_decimal= Decimal
  c_single = single(NaN);
  c_double = double(NaN);
  c_string = String('');
  c_TwoCharString = UnicodeString('');
  c_currency = currency(0.0);
//var
//  v_date:TDATE;

begin
  case expectedtype of
    vt_boolean:       Result := False;
    vt_int8:          Result := c_int8;
    vt_uint8:         Result := c_uint8;
    vt_int16:         Result := c_int16;
    vt_uint16:        Result := c_uint16;
    vt_int32:         Result := c_int32;
    vt_uint32:        Result := c_uint32;
    vt_int64:         Result := c_int64;
    vt_uint64:        Result := c_uint64;
    vt_single:        Result := c_single;
    vt_double:        Result := c_double;
    vt_string:        Result := c_string;
    vt_TwoCharString: Result := c_TwoCharString;
    vt_currency:      Result := c_currency;
    vt_date:          Result := Now;
  otherwise
    Result := False;
  end;
end;


Function CharPosInString(ch:char; str:TUTF8String; Start:integer):integer;
var idx:integer;
begin
  Result:=-1;
  for idx:=start to Length(str) do
  begin
    if str[idx] = ch then
    begin
      //writeln('"', ch,'" in "',str,'" at ',idx);
      exit(idx);
    end;
  end;
  //writeln('"', ch,'" not in "',str,'" ');
end;


//constructor TStringConvError.create;
//begin
//  inherited;
//  self.ClearError;
//end;
//
//destructor  TStringConvError.Destroy;
//begin
//  inherited Destroy;
//end;
//
//procedure TStringConvError.ClearError;
//begin
//  self._ConvError:=SCE_NoError;
//  self._FileError:=SCEFE_NoError;
//  self._MemoryError:=SCEME_NoError;
//end;
//
//function TStringConvError.GetConvError:TStringConvError_set;
//begin
//  result := self._ConvError;
//end;
//
//procedure TStringConvError.SetConvError(NewError:TStringConvError_set);
//begin
//  self.ClearError;
//  self._ConvError := NewError;
//end;

  function _StringToInt(source:TUTF8String; var ConvError:TStringConvError):Int64;
  var errorpos:integer;
      value:int64;
  begin
    ConvError.ClearError;
    val(source, value, errorpos);
    Result:=0;
    if errorpos > 0 then
      ConvError.ConvError := SCE_illegal_character
    else
      Result:= value;
	end;

  function _StringToUInt(source:TUTF8String; var ConvError:TStringConvError):Int64;
  var errorpos:integer;
    value:uint64;
  begin
    ConvError.ClearError;
    val(source, Value, errorpos);
    Result:=0;
    if errorpos > 0 then
      ConvError.ConvError := SCE_illegal_character
    else
      Result:= value;
  end;


  function StringToInt64(source:TUTF8String):TResValint64;
  var ConvError:TStringConvError;
      TmpRes:Int64;
  begin
    TmpRes:=_StringToInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(TmpRes) else Result.SetFailure(ConvError);
	end;

  function StringToUInt64(source:TUTF8String):TResValUint64;
  var ConvError:TStringConvError;
      TmpRes:UInt64;
  begin
    TmpRes:=_StringToUInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(TmpRes) else Result.SetFailure(ConvError);
	end;

  //type
  //    generic StringToIntX<ResultType> = Function (source:TUTF8String; var error:TStringConvError):ResultType;
  //    begin
  //      Result:=StringToInt64(source, error);
  //    end;


 // function StringToInt32(source:TUTF8String):TResValInt32;
 // var ConvError:TStringConvError;
 //     TmpRes:Int64;
 // begin
 //   TmpRes:=_StringToInt(source, ConvError);
 //   if ConvError.NoErrors then Result.SetResult(int32(TmpRes)) else Result.SetFailure(ConvError);
	//end;
 //
 // function StringToInt16(source:TUTF8String):TResValInt16;
 // var ConvError:TStringConvError;
 //     TmpRes:Int64;
 // begin
 //   TmpRes:=_StringToInt(source, ConvError);
 //   if ConvError.NoErrors then Result.SetResult(int16(TmpRes)) else Result.SetFailure(ConvError);
	//end;
 //
 // function StringToInt8(source:TUTF8String):TResValint8;
 // var ConvError:TStringConvError;
 //     TmpRes:Int64;
 // begin
 //   TmpRes:=_StringToInt(source, ConvError);
 //   if ConvError.NoErrors then Result.SetResult(int8(TmpRes)) else Result.SetFailure(ConvError);
	//end;
 //
 // function StringToUInt32(source:TUTF8String):TResValUInt32;
 // var ConvError:TStringConvError;
 //     TmpRes:UInt64;
 // begin
 //   TmpRes:=_StringToUInt(source, ConvError);
 //   if ConvError.NoErrors then Result.SetResult(Uint32(TmpRes)) else Result.SetFailure(ConvError);
	//end;
 //
 //
 // function StringToUInt16(source:TUTF8String):TResValUInt16;
 // var ConvError:TStringConvError;
 //     TmpRes:UInt64;
 // begin
 //   TmpRes:=_StringToUInt(source, ConvError);
 //   if ConvError.NoErrors then Result.SetResult(Uint16(TmpRes)) else Result.SetFailure(ConvError);
	//end;
 //
 //
 // function StringToUInt8(source:TUTF8String):TResValUInt8;
 // var ConvError:TStringConvError;
 //     TmpRes:UInt64;
 // begin
 //   TmpRes:=_StringToUInt(source, ConvError);
 //   if ConvError.NoErrors then Result.SetResult(Uint8(TmpRes)) else Result.SetFailure(ConvError);
	//end;

  function StringToType(source:TUTF8String):TResValInt32;
  var ConvError:TStringConvError;
      TmpRes:Int64;
  begin
    TmpRes:=_StringToInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(int32(TmpRes)) else Result.SetFailure(ConvError);
	end;

  function StringToType(source:TUTF8String):TResValInt16;
  var ConvError:TStringConvError;
      TmpRes:Int64;
  begin
    TmpRes:=_StringToInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(int16(TmpRes)) else Result.SetFailure(ConvError);
	end;

  function StringToType(source:TUTF8String):TResValint8;
  var ConvError:TStringConvError;
      TmpRes:Int64;
  begin
    TmpRes:=_StringToInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(int8(TmpRes)) else Result.SetFailure(ConvError);
	end;


  function StringToUType(source:TUTF8String):TResValUInt8;
  var ConvError:TStringConvError;
      TmpRes:UInt64;
  begin
    TmpRes:=_StringToUInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(Uint8(TmpRes)) else Result.SetFailure(ConvError);
	end;

  function StringToUType(source:TUTF8String):TResValUInt16;
  var ConvError:TStringConvError;
      TmpRes:UInt64;
  begin
    TmpRes:=_StringToUInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(Uint16(TmpRes)) else Result.SetFailure(ConvError);
	end;

  function StringToUType(source:TUTF8String):TResValUInt32;
  var ConvError:TStringConvError;
      TmpRes:UInt64;
  begin
    TmpRes:=_StringToUInt(source, ConvError);
    if ConvError.NoErrors then Result.SetResult(Uint32(TmpRes)) else Result.SetFailure(ConvError);
	end;


  function StringToDouble(source:TUTF8String):TResValDouble;
  var
      res:double;
      error:TStringConvError;
  begin
    Res:= 0.0;
    try
      Res:=StrToFloat(source, DefaultFileFormatSettings);
      Result.SetResult(res);
    Except
      on E : Exception do
      begin
        {$if DEBUGLVL>=1}
        log.LogError('Exception in float conversion', INFOLINE , {$i %line%});
        {$endif}
        error.ConvError:= SCE_illegal_character; //(the convert error exception is converted into an error :-)
        Result.SetFailure(error);
      end;
    end;

  end;

  function StringToSingle(source:TUTF8String):TResValSingle;

  begin
    Result:=StringToDouble(source);
  end;

  function StringToDate(source:TUTF8String ):TResValTDateTime;
  var error:TStringConvError;
      Res:TDateTime;

  //var
  //    formatset:TFormatSettings;
  begin
    Res:=Now;
    error.ConvError:= SCE_NoError;
    try
      Res:=StrToDateTime(source,DefaultFileFormatSettings);
      Result.SetResult(res);
    Except
      //error.ConvError:=SCE_illegal_character;
      //Result.SetFailure(error);
      on Excpt : Exception do
      begin
        {$if DEBUGLVL>=1}
        log.LogError('Exception in Date conversion. Retries as float/double.', INFOLINE , {$i %line%});
        {$endif}
        Result:=StringToDouble(source); //the StringToDouble Resets failure status to the result of the double conversion
      end;
    end;
    //if error.ConvError = SCE_NoError then Result:=Result.; //Get a valid value in case converion fails
  end;

  function StringToBoolean(source:TUTF8String):TResValBoolean;
  var error:TStringConvError;
  begin
    try
      Result.SetResult(StrToBool(source));
    Except
      on E : Exception do
      begin
        error.ConvError:= SCE_illegal_character; //(the convert error exception is converted into an error :-)
        {$if DEBUGLVL>=1}
        log.LogError( 'SCE_illegal_character :'+ e.ToString, INFOLINE , {$i %line%});
        {$endif}
        Result.SetFailure(error);
      end;
    end;
  end;

  function StringToCurrency(source:TUTF8String):TResValCurrency;
    var error:TStringConvError;
        ResVal:Currency;
  begin
    ResVal:=0;
    if TryStrToCurr(source,Resval, DefaultFileFormatSettings) then
      Result.SetResult(ResVal)
    else
    begin
      error.ConvError:=SCE_illegal_character;
      Result.SetFailure(error);
		end;
	end;



constructor TEscapeCharStream.Create(EscChar:Char);
begin
  inherited create;
  self.EscapeChar:=EscChar;
end;

procedure TEscapeCharStream.Reset;
begin
  self.EscCharState:=ECS_NormalState; //Awaits escapechar
  {$if DEBUGLVL >= 4}
  writeln('[TEscapeCharStream.Reset] ',  INFOLINE , {$i %line%});
  {$endif}
end;

function TEscapeCharStream.ParseChar(ch:UTF8Char):TExtendedChar;
begin
  case self.EscCharState of
    ECS_NormalState:
      begin
        if ch = self.EscapeChar then //Not a final char, so wait for the next
        begin
          {$if DEBUGLVL >= 4}
          writeln('[ECS_normalstate: ch = escapechar] ',  INFOLINE , {$i %line%});
          {$endif}
          self.EscCharState:= ECS_InEscape;
          self.CurrentChar.IsValid:=False;
          self.CurrentChar.IsChar:=False;
          self.CurrentChar.ch:=self.EscapeChar;
        end
        else
        begin
          {$if DEBUGLVL >= 4}
          writeln('[ECS_normalstate: ch = not escapechar] ',  INFOLINE , {$i %line%});
          {$endif}
          self.EscCharState:= ECS_NormalState; //pass through of char
          self.CurrentChar.IsValid:=True;
          self.CurrentChar.IsChar:=True;
          self.CurrentChar.ch:=ch;
        end;
      end;
    ECS_InEscape:
      begin
        self.EscCharState:= ECS_NormalState;
        //update to handle nl+CR
        if ch = self.EscapeChar then //this char is a normal char escaped in to two chars
        begin
          {$if DEBUGLVL >= 4}
          writeln('[ECS_EscCharState: ch = escapechar] ',  INFOLINE , {$i %line%});
          {$endif}
          self.CurrentChar.ch:=self.EscapeChar; //Normal char
          self.CurrentChar.IsValid:=True;
          self.CurrentChar.IsChar:=True;
        end
        else
        begin
          {$if DEBUGLVL >= 4}
          writeln('[ECS_EscCharState: ch = not escapechar] ',  INFOLINE , {$i %line%});
          {$endif}
          self.CurrentChar.ch:=ch;
          self.CurrentChar.IsValid:=True;
          self.CurrentChar.IsChar:=False; //Contains a potential function code (like sync)
        end;
      end;
    otherwise //Should never occur, but if state gets mangled then it may reach here.
      begin
        self.EscCharState:= ECS_NormalState; //Return to defined state
        self.CurrentChar.IsValid:=False;  //Not valid
        self.CurrentChar.IsChar:=False;   //not a char
        self.CurrentChar.ch:=Self.EscapeChar; //define value
      end;
  end;
  Result := Self.CurrentChar;
end;

function TEscapeCharStream.CharToESCStr(ch:Char; IsChar:boolean):UTF8String;
begin
  if not IsChar then
  begin
    Result:= self.EscapeChar + ch;
  end
  else
  begin
    if ch = self.EscapeChar then
    begin
      Result := self.EscapeChar + self.EscapeChar;
      {$if DEBUGLVL >= 3}
      log.LogStatus('InEsc', INFOLINE , {$i %line%});
      {$endif}
    end
    else
      Result := ch;
  end;
end;

function TEscapeCharStream.StringToESCStr(Str:UTF8String):UTF8String;
var
  idx:integer;
  valpart:UTF8String;
begin
  Result:='';
  //writeln('ESCstr src ', StringDumpToHex(str));
  for idx:=1 to length(str) do
  begin
    valpart := self.CharToESCStr(str[idx], True);
    //write('STES VP(',ord(str[idx]),') "',str[idx],'"="', valpart,'" ');
    Result:=Result + valpart;
  end;
end;

function TStreamStringParser.HasErrors:boolean;
begin
  result := self.InternalError.HasErrors;
end;

procedure TStreamStringParser.SetSceError(SetError:TStringConvError);
begin
  self.InternalError := SetError;
end;

procedure TStreamStringParser.SetSceError(SetError:TStringConvError_set);
begin
  self.InternalError.ConvError := SetError;
end;

procedure TStreamStringParser.SetSceMeError(SetError:TMemoryError_set);
begin
  self.InternalError.MemoryError:=SetError;
end;

Function TStreamStringParser.GetSizeOfSizeBlock(VT:TvartypeSet):integer;
begin;
  //  if (VarTypeID  = varstring) or (VarTypeID = varolestr) then //Unicode or TTwoCharStrings are converted to VarOLEStr
  if (VT  = vt_string) or (VT = vt_olestr) then //Unicode or TTwoCharStrings are converted to VarOLEStr
  begin
    exit(StrHexSizeSize);
  end
  else
  begin
    exit(OtherHexSizeSize);
  end;
end;

Function TStreamStringParser.GetSizeOfSizeBlock(VarTypeID:Integer):integer;
begin
  Result:= GetSizeOfSizeBlock(VariantTypeType_to_TvartypeSet(VarTypeID));
end;

Function TStreamStringParser.GetSizeOfSizeBlock(Token:Char; var VT:TvartypeSet):integer;
var
  VarTypeID : UInt16;
begin
  VarTypeID:=Ident_to_varianttype(token);
  VT:=VariantTypeType_to_TvartypeSet(VarTypeID);
  if VT = vt_error then
  begin
    exit(-1);
  end;
  Result := GetSizeOfSizeBlock(VT);
end;

function TStreamStringParser.GetState:integer;
begin
  Result:= integer(self.ParserState);
end;

constructor TStreamStringParser.Create;
var
  init_ok:boolean;
begin
  inherited;
  init_ok := True;

  self.InternalError := SCE_ClearError;

  if init_ok then
  begin
    try
      self.EscParser := TEscapeCharStream.Create(ECS_ESCAPECHAR);

      self.StrHexSizeSize := 8; //32 bit -> 8 hexchars
      Self.OtherHexSizeSize := 2; //8 bit for other types -> 2 hexchars
      Self.SeparatorChar := ''; //Ne separator is used between size and value
      Self.separatorSize := 0; //No chars for separator

      Self.IdSize := 1; //one char for id
      Self.MinSizeSize := 2; //two chars for min size (one byte)
      Self.MinStrSize := 0; //zero chars for empty string
      Self.MinSize := IdSize + MinSizeSize + MinStrSize;

      Self.ActivateSync; //Sync chars ensure that a value can be found even if some chars of a file is distorted

      Self.ActivateChecksum; //By default CRC is enabled

      self.ResetState; //Reset StateMachine used for parsing incoming strings
    Except

      Self.InternalState:=SPS_Error; //We could not create parser -> caller should stop program

      Self.InternalError.ConvError:=SCE_MemoryError; //signal out of memory error
      self.InternalError.MemoryError := SCEME_error_0;
      {$if DEBUGLVL>=1}
      log.LogError('Could not allocate EscParser', INFOLINE , {$i %line%});
      {$endif}
    end;
  end;
end;

Destructor TStreamStringParser.Destroy;
begin
  self.EscParser.Destroy;
  //inherited destroy;
end;

procedure TStreamStringParser.ResetState;
begin
  self.InternalState := self.FirstState;
  //if self.InternalError <> Nil then self.InternalError := SCE_ClearError;
  self.InternalInjectedDetected:=False;
  self.EscParser.Reset;
end;

function TStreamStringParser.Is_Done:boolean;
begin
  if (self.InternalState = SPS_Done) or (self.InternalState = SPS_error) then
    Result:=True
  else
    Result:=false;
end;

//function TStreamStringParser.Has_error:boolean;
//begin
//  if SCE_NoErrors(self.InternalError) then Result:=False else Result:=True;
//end;

function TStreamStringParser.ActivateChecksum:boolean;
begin
  self.InternalUseChecksum:=True;
  self.lastState := SPS_GetCheckSum;
  Self.ResetState;
  Result:=self.InternalUseChecksum;
end;

function TStreamStringParser.DisableChecksum:boolean;
begin
  self.InternalUseChecksum:=False;
  self.lastState := SPS_GetPayload;
  Self.ResetState;
  Result:=self.InternalUseChecksum;
end;

function TStreamStringParser.ActivateSync:boolean;
begin
  self.firststate:=SPS_GetSync;
  self.InternalUseSync:=True;
  Self.ResetState;
  Result:=self.InternalUseSync;
end;

function TStreamStringParser.DisableSync:boolean;
begin
  self.firststate:=SPS_GetId;
  self.InternalUseSync:=False;
  Self.ResetState;
  Result:=self.InternalUseSync;
end;

function TStreamStringParser.SetSync(active:boolean):boolean;
begin
  if active then Result:=self.ActivateSync else result:=self.DisableSync;
end;

function TStreamStringParser.SetCRC(active:boolean):boolean;
begin
  if active then Result:=self.ActivateChecksum else result:=self.DisableChecksum;
end;

function TStreamStringParser.GetSizeOfPayloadCheckSum(checksumval:uint8):TCRC_type;
begin
  Result:=InvalidCRCType;
  checksumval:= checksumval and STS_CHKSZ_PAYLOAD_MASK;
  case checksumval of
    STS_CHKSZ_PAYLOAD_16: begin result:= Use16BitCRC; {$if DEBUGLVL>=4} write('<PayloadCRCsize 16>'); {$endif} end;
    STS_CHKSZ_PAYLOAD_32: begin result:= Use32BitCRC; {$if DEBUGLVL>=4} write('<PayloadCRCsize 32>'); {$endif} end;
    STS_CHKSZ_PAYLOAD_64: begin result:= use64BitCRC; {$if DEBUGLVL>=4} write('<PayloadCRCsize 64>'); {$endif} end;
    STS_CHKSZ_PAYLOAD_128: begin result:= use128BitCRC; {$if DEBUGLVL>=4} write('<PayloadCRCsize 128>'); {$endif}end;
    otherwise begin Result:= InvalidCRCType; {$if DEBUGLVL>=1} write('<Invalid PayloadCRC !>'); {$endif} end;
  end;
  {$if DEBUGLVL>=3} write('(GetSzPayldCRC val=', byte(Result),') '); {$endif}
end;

function TStreamStringParser.GetSizeOfHeaderCheckSum(checksumval:uint8):TCRC_type;
begin
  Result:=InvalidCRCType;
  checksumval:= checksumval and STS_CHKSZ_HEADER_MASK;
  case checksumval of
    STS_CHKSZ_HEADER_16:begin result:= Use16BitCRC; {$if DEBUGLVL>=4} write('<HeaderCRCsize 16>'); {$endif} end;
    STS_CHKSZ_HEADER_32:begin result:= Use32BitCRC; {$if DEBUGLVL>=4} write('<HeaderCRCsize 32>'); {$endif} end;
    STS_CHKSZ_HEADER_64:begin result:= use64BitCRC; {$if DEBUGLVL>=4} write('<HeaderCRCsize 64>'); {$endif} end;
    STS_CHKSZ_HEADER_128:begin result:= use128BitCRC; {$if DEBUGLVL>=4} write('<HeaderCRCsize 128>'); {$endif} end;
    otherwise begin Result:= InvalidCRCType; {$if DEBUGLVL>=1} write('<Invalid HeaderCRC!>'); {$endif} end;
  end;
  {$if DEBUGLVL>=3} write('(GetSzHeaderCRC val=', byte(Result),') '); {$endif}
end;

function TStreamStringParser.UpdateStateMachine(newdata: UTF8Char):TStreamstringParserState;

var errorpos : integer;
    vt : TVariantStrTupple;
    ch : TExtendedChar;
    value : integer;
    CkhSumVal : Uint32;
    chksumstr : UTF8String;
    CheckSumSize_Value: Uint8;
    Resu64:TResValUint64;
    TmpPayLoadRes:TResVariant;


    function CurrentStateStr:String;
    begin
      case self.InternalState of
        SPS_GetSync:            exit('[SPS_GetSync]');
        SPS_GetId:              exit('[SPS_GetId]');
        SPS_GetChecksumSizes:   exit('[SPS_GetChecksumSizes]');
        SPS_GetInjectedId:      exit('[SPS_GetInjectedId]');
        SPS_GetInjectedSize:    exit('[SPS_GetInjectedSize]');
        SPS_GetInjectedPayload: exit('[SPS_GetInjectedPayload]');
        SPS_GetSize:            exit('[SPS_GetSize]');
        SPS_GetSeparator:       exit('[SPS_GetSeparator]');
        SPS_GetCheckSumHeader:  exit('[SPS_GetCheckSumHeader]');
        SPS_GetPayload:         exit('[SPS_GetPayload]');
        SPS_GetCheckSum:        exit('[SPS_GetCheckSum]');
        SPS_Done:               exit('[SPS_Done]');
        SPS_Error:              exit('[SPS_Error]');
      otherwise
        exit('[State unknown]');
      end;
    end;

    procedure SetDone;
    begin
      self.InternalState:= SPS_Done;
    end;

    procedure SetError;
    begin
      {$if DEBUGLVL>=1}
      log.LogError('Error set.'+ CurrentStateStr, INFOLINE , {$i %line%});
      {$endif}
      if SCE_NoErrors(self.InternalError) then self.InternalError.ConvError:=SCE_Logic_error; // Should not happen -> Error state with no error (means logical error in code)
      self.InternalState:= SPS_error;
    end;

    procedure Get_Checksum(newdata:char; StrToCheck:TUTF8String; NextState:TStreamstringParserState; CRC_type:TCRC_type);
    var CheckSumExpectedSize:integer;
        function GetCRCSizeInChar(CRC_type:TCRC_type):uint16;
        begin
//          writeln('CRC type received = ', byte(CRC_type));
          case CRC_type of
            Use16BitCRC: Result:=4;
            Use32BitCRC: Result:=8;
            Use64BitCRC: Result:=16;
            Use128BitCRC: Result:=32;
          otherwise
            Result:=8;
          end;
        end;

    begin
      self.counter += 1;
      self.checksumString := self.checksumString + newdata;
      ChecksumExpectedSize:= GetCRCSizeInChar(CRC_type);
      if self.counter >= ChecksumExpectedSize then
      begin
        ChkSumStr := CrcStr(StrToCheck,CRC_type);
        if (self.checksumString = chksumstr) then
        begin
          self.counter := 0;
          self.InternalState := NextState;  //Return to idle when done
          {$if DEBUGLVL>=3}
          log.LogStatus('CRC OK.'+ CurrentStateStr +' Received='+ self.checksumString , INFOLINE , {$i %line%});
          {$endif}
        end
        else
        begin

          self.InternalError.ConvError:=SCE_Checksum_Error; //Note that both header and payload checksum both gives the same error!
          {$if DEBUGLVL>=1}
          log.LogError('CRC failed.'+ CurrentStateStr +' Received='+self.checksumString+
                       ' Calculated='+ chksumstr, INFOLINE , {$i %line%});
          {$endif}
          SetError;
        end;
      {$if DEBUGLVL >= 4}
      end
      else
      begin
        write ('Count ',self.counter,' of expected ', ChecksumExpectedSize,' ');
      end;
      {$else}
      end;
      {$endif}
    end;


begin

  value := ord(newdata);
  ch := self.EscParser.ParseChar(newdata);
  if not ch.IsValid then //che char received from outside was an escapechar and now we have to wait for the next char to set a valid char (code)
  begin
    {$if DEBUGLVL >= 5}
    writeln('[ch.isvalid = false] ', INFOLINE , {$i %line%});
    {$endif}
    exit(self.InternalState);
  end;

  //{$if DEBUGLVL >= 3}
  //log.LogStatus('State: '+ CurrentStateStr, INFOLINE , {$i %line%});
  //{$endif}

  {$if DEBUGLVL >= 5}
  if ch.IsChar then write('C[',ch.ch,'] ') else write('N[',ch.ch,'] ');
//  write('[', CurrentStateStr,']');
  {$endif}
  case self.InternalState of

    SPS_GetSync: //Any char received is considered an ID in this state
      begin //wait for sync char (escapechar + syncchar
        if self.InternalUseSync then
        begin
          if (ch.IsChar = False)    And
             (ch.ch = ECS_SYNCCHAR) then //We have a syncchar present
          begin
            {$if DEBUGLVL >= 4}
            write('<sync found> ');
            {$endif}
            self.InternalState := SPS_GetId;
            exit(self.InternalState);
          end
          else
          begin
            {$if DEBUGLVL >= 4}
            write('<still scans for sync> ');
            {$endif}
          end;
        end
        else
        begin //We should not reach this state if we do not use internalsync
          {$if DEBUGLVL>=1}
          log.LogError('Looking for sync with sync disabled (recovered).'+ CurrentStateStr, INFOLINE , {$i %line%});
          {$endif}
          self.ResetState; //but if we get here, we recover to a known state (assumming ResetState works correctly)
        end;
      end;
    SPS_GetId:
      begin
        {$if DEBUGLVL>=5}
        log.LogStatus(CurrentStateStr , INFOLINE , {$i %line%});
        {$endif}

        self.ExpectedType := vt_error;
        self.ReceivedType := vt_error;
        self.payloadString:='';
        if newdata = STRID_VarInjectedHeader then
        begin
          {$if DEBUGLVL >= 5}
          write('<inj strt>');
          {$endif}
          if self.InternalInjectedDetected then //there can only be one (injected header)
          begin
            self.InternalError.ConvError:=SCE_syntax_error;
            SetError; //set error state
            {$if DEBUGLVL>=1}
            log.LogError('Unknown Id in stream', INFOLINE , {$i %line%});
            {$endif}
            exit(self.InternalState); //return (exit) with the internal state
          end
          else
          begin
            {$if DEBUGLVL >= 3}
            log.LogStatus('<Injection detected>', INFOLINE , {$i %line%}));
            {$endif}
            self.headerBlock := newdata; //
            self.InternalInjectedDetected:=True;
            self.internalstate := SPS_GetInjectedId;
            self.checksumString:='';
            self.counter:=0;
            self.Injected:='';
            self.InjectedHeader:=NewData; //Store it in injectedHeader
            //WriteCurrentState;
            exit(self.InternalState); //return (exit) with the internal state
          end;
        end;


        //for strings 64 bit sizes are allowed for others only 16bit sizes
        self.ExpectedSizeSize:=GetSizeOfSizeBlock(newdata, self.ExpectedType); //sideeffect also updats VT
        if self.ExpectedType = vt_error then //unknown types results in an error type
        begin
          self.InternalError.ConvError:=SCE_ident_Error;
          SetError;
          {$if DEBUGLVL>=1}
          log.LogError('Unknown datatype in stream', INFOLINE , {$i %line%});
          {$endif}
          {$if DEBUGLVL >= 4}
          write('(ERR: Unknown datatype in stream )');
          {$endif}
          exit(self.InternalState); //return (exit) with the internal state
        end;
        if not self.InternalInjectedDetected then
        begin
          self.InjectedHeader:=''; //internal header (id+size)
          self.Injected:=''; //injected payload
        end;
        self.ID := NewData;
        self.ReceivedType:=self.ExpectedType;
        self.counter:=0;
        self.sizeString:='';
        self.payloadString:='';
        self.checksumString:='';
        self.headerBlock:= NewData;
        self.InternalState:=SPS_GetSize; // fandt id tag -> new state
      end;


    SPS_GetInjectedId:
      begin
        if CharPosInString(newdata, InjectedIdChars,1) > 0 then //is it in the list of known IDs
        begin
          {$if DEBUGLVL >= 4}
          write(' Known injection ');
          {$endif}
          self.InjectedId:=newdata;
          self.InjectedHeader:=self.InjectedHeader + newdata; //Store id as part of received string
          self.counter:=0;
          self.InternalState:= SPS_GetInjectedSize;
          self.sizeString:='';
          exit(self.InternalState); //return (exit) with the internal state
        end
        else
        begin
          self.InternalError.ConvError:=SCE_ident_Error;
          {$if DEBUGLVL >= 4}
          write('Unknown injected type in stream', INFOLINE , {$i %line%});
          {$endif}
          SetError;
          {$if DEBUGLVL>=1}
          log.LogError('Unknown injected type in stream', INFOLINE , {$i %line%});
          {$endif}
          exit(self.InternalState); //return (exit) with the internal state
        end;
      end;
    SPS_GetInjectedSize:
      begin
        self.counter += 1;
        self.sizeString := self.sizeString + newdata;
        //write('Getsize(',self.counter,'/',self.ExpectedSizeSize,')="',newdata,'" ');
        if self.counter >= InjectedHeaderSizeInChars then
        begin
          //write('<Got enough chars for injection payload size> ');
          ErrorPos :=0;

          Resu64:=HexToUInt64(self.sizeString);
          if not Resu64.Success then
          begin
            {$if DEBUGLVL>=1}
            log.LogError('Could not parse size', INFOLINE , {$i %line%});
            {$endif}
            self.InternalError.ConvError := SCE_length_Error;
            SetError;
            exit(self.InternalState);
          end
          else
            Self.ExpectedPayloadSize:=Resu64.Result;

          self.InjectedSize:=Self.ExpectedPayloadSize;
          self.Injected:='';
          Self.InjectedHeader:=Self.InjectedHeader + self.sizeString;
          self.counter:=0;
          self.InternalState:= SPS_GetInjectedPayload;
          exit(self.InternalState); //return (exit) with the internal state
        end;
      end;

    SPS_GetInjectedPayload:
      begin
        //WriteCurrentState;
        self.counter += 1;
        self.injected := self.injected + newdata;

        {$if DEBUGLVL >= 4}
        write(' Inj(',self.counter,'/',self.ExpectedPayloadSize,')="',newdata,'" ');
        {$endif}
        if self.counter >= self.ExpectedPayloadSize then
        begin
          {$if DEBUGLVL>=3}
          log.LogStatus('Got enough chars for injection payload', INFOLINE , {$i %line%});
          {$endif}
          self.InternalInjectedDetected:= True;
          self.InternalState:= SPS_getId;  //
          self.injectionhandler(self.InjectedId, self.Injected);
          exit(self.InternalState); //return (exit) with the internal state
        end;
      end;
    SPS_GetSize:
      begin
        self.counter += 1;
        self.sizeString := self.sizeString + newdata;
        {$if DEBUGLVL >= 4}
        write('Getsize(',self.counter,'/',self.ExpectedSizeSize,')="',newdata,'" ');
        {$endif}
        if self.counter >= self.ExpectedSizeSize then
        begin
          Resu64:=HexToUInt64(self.sizeString);
          if not Resu64.Success then
          begin
            self.InternalError.ConvError := SCE_length_Error;
            SetError;
            {$if DEBUGLVL>=1}
            log.LogError('Could not parse payload size', INFOLINE , {$i %line%});
            {$endif}
            //writeln('Could not parse payload size');
            exit(self.InternalState);
          end
          else
            Self.ExpectedPayloadSize:= Resu64.Result;
          self.counter := 0;
          self.InternalState:= SPS_GetChecksumSizes;
        end;
      end;
    (*
    STS_CHKSZ_BASE  = $20; // = #32 = space
    STS_CHKSZ_16    = $0;
    STS_CHKSZ_32    = $1;
    STS_CHKSZ_64    = $2;
    STS_CHKSZ_128   = $3;
    STS_CHKSZ_PAYLOAD_MASK = $3;
    STS_CHKSZ_PAYLOAD_16   = $0;
    STS_CHKSZ_PAYLOAD_32   = $1;
    STS_CHKSZ_PAYLOAD_64   = $2;
    STS_CHKSZ_PAYLOAD_128  = $3;
    STS_CHKSZ_HEADER_MASK  = $C;
    STS_CHKSZ_HEADER_16    = $0;
    STS_CHKSZ_HEADER_32    = $4;
    STS_CHKSZ_HEADER_64    = $8;
    STS_CHKSZ_HEADER_128   = $C;
    *)

    SPS_GetChecksumSizes:
      begin
        ChkSumSizeStr := NewData;
        CheckSumSize_Value  := Ord(newdata);

        CheckSumSize_Header := GetSizeOfHeaderCheckSum(CheckSumSize_Value); //Expected size
        CheckSumSize_Payload:= GetSizeOfPayloadCheckSum(CheckSumSize_Value); //Expected size
        //write('{GetCkSmSz head =', byte(checkSumSize_Header),'} ');
        //write('{GetCkSmSz pay =', byte(CheckSumSize_Payload),'} ');

        if separatorSize = 0 then
        begin
          if self.UsesChecksum then
          begin
            self.InternalState := SPS_GetCheckSumHeader;
            self.counter := 0;
            self.checksumString := '';
          end
          else
          begin
            self.payloadString:='';
            self.InternalState:=SPS_GetPayload //if no separator skip looking for one
          end;
        end
        else
        begin
          self.InternalState:=SPS_GetSeparator;
        end;

      end;

    SPS_GetSeparator:
      begin
        self.counter += 1;
        if self.counter >= separatorSize then
        begin
          self.counter:=0;
          self.payloadString:='';
          self.InternalState:=SPS_GetPayload;
        end;
      end;

    SPS_GetCheckSumHeader:
      begin
        //  InjectedHeader := STRID_VarInjectedHeader + injectedtype + SizeInjected + InjectedPayload
        //header := InjectedHeader + Token  + SizeHex +
        //          CheckSumSizeToChar ( Use32BitCRC, Use64BitCRC) +
        //          self.SeparatorChar ;
        //  chksum_header  := CrcStr(self.InternalUseChecksum, header);
        self.payloadString:='';
        if self.InternalInjectedDetected then
        begin
          //write('(GetCkSumHd inj sizetype=', byte(CheckSumSize_Header),') ');
          Get_Checksum(newdata,
                       self.InjectedHeader + //= STRID_VarInjectedHeader + injectedtype + SizeInjected
                       self.injected +
                       self.id +
                       self.sizeString +
                       ChkSumSizeStr ,
                       SPS_GetPayload,
                       CheckSumSize_Header)
        end
        else
        begin
          //write('(GetCkSumHd var sizetype=', byte(CheckSumSize_Header),') ');
          Get_Checksum(newdata,
                     self.id +
                     self.sizeString +
                     ChkSumSizeStr,
                     SPS_GetPayload, CheckSumSize_Header);
        end;
      end;

    SPS_GetPayload:
      begin
        self.counter += 1;
        self.payloadString := self.payloadString + newdata;

        {$if DEBUGLVL >= 4}
        write('GetPayload(',self.counter,'/',self.ExpectedPayloadSize,')="',newdata,'" ');
        {$endif}
        if self.counter >= self.ExpectedPayloadSize then
        begin
          if self.UsesChecksum then
          begin
            self.InternalState := SPS_getChecksum;
            self.counter := 0;
            self.checksumString := '';
          end
          else
          begin
            SetDone;
          end;
          //self._payload := StreamStringToVariant(self.payloadString, self.ReceivedType, self.InternalError);
          vt.var_type :=  TvartypeSet_to_VariantTypeType (self.ReceivedType);
          {$if DEBUGLVL >= 4}
          write('/PayloadStr="',self.payloadString,'"/ ');
          {$endif}
          vt.str := self.payloadString;
          TmpPayLoadRes:=StringTuppleToVariant(vt);
          if TmpPayloadRes.Success = False then
          begin
             self.SetSceError(SCE_payload_conversion_Error);
             self._payload:=Null;
          end
          else
          self._payload := TmpPayLoadRes.Result;
          self.PostParseHandler(self._payload, self.InternalError);
        end;
      end;

    SPS_getChecksum:
      begin
        Get_Checksum(newdata,self.payloadString, SPS_Done, CheckSumSize_Payload); //64 bit is used since a long textstring may be payload
      end;

    SPS_done:
      begin
        //Do nothing but wait for caller to call reset
        SetDone;

      end;
    SPS_Error:
      begin
        //write('(SPS_Error) ');
        SetError;
      end;
  otherwise
    {$if DEBUGLVL>=1}
    log.LogError('OtherWise reached in update state machine (should not occur!)', INFOLINE , {$i %line%});
    {$endif}
    self.InternalError.ConvError:=SCE_Logic_error;
    SetError;
  end;
  Result:= self.InternalState; //always return internal state
end;


 //Forældet: al reference SKAL fjernes fra al kode!!!!
  //Function SCE_ClearError:TStringConvError;
  //begin
  //  Result.ClearError;
  //end;
  //
  //Function SCE_NoErrors(error:TStringConvError):boolean;
  //begin
  //  if error.ConvError = SCE_NoError then Result:= True else Result := False;
  //end;
  //Function SCE_HasErrors (error:TStringConvError):boolean;
  //begin
  //  result:= Not( SCE_NoErrors(error));
  //end;

  function VarTypeTextToType(const StrVarType: string): integer;
  type
    Tvariant_tupple = Record
                        names:TUTF8String;
                        supported :Boolean;
                      end;

  var
      idx:integer;
      vr:Variant;
  begin
    idx:= low(variant_names);
    while (idx <= high(variant_names)) And
          (LowerCase( variant_names[idx and varTypeMask]) <> LowerCase(StrVarType) ) do
    begin
      idx += 1;
    end;
    if idx > high(variant_names) then
    begin
      Result:= varunknown;
      exit(Result);
    end;
    if variant_supported[idx] then
      Result:= idx
    else
      Result:= varunknown;
  end;


  Function TTwoCharStringToRawString(source:TUnicodeString):TUTF8String;
  begin
    Result:=UTF8Encode(source);
  end;

  Function RawstringToTTwoCharString(source:TUTF8String):TUniCodeString;
  begin
    Result:=UTF8Decode(source);
  end;

  /// @brief: converts a variant to a tupple consisting of var_type (from variant) and a string
  /// @param source: variant to convert
  ///  param vt: deprecated
  //function VariantToStringTupple(source:variant):TVariantStrTupple; //  ; vt:TvartypeSet):TVariantStrTupple;
  //begin
  //
  //end;

  function VariantToStringTupple(source:variant):TVariantStrTupple; //  ; vt:TvartypeSet):TVariantStrTupple;
  Const
      NULL_STR = '(NULL)';

  var val:Double;
      Var_Date:TDate;
      vartype_int : integer;
      tmpstr:TUnicodeString;
      //error:TStringConvError;
      TmpUtfStr : UTF8String;

  begin

    {$if DEBUGLVL>=3}
    write('Var2StrTup type=',Result.var_type);
    {$endif}

    Result.var_type :=VarType(source);
    if (Result.var_type = varOleStr) then
    begin
      {$if DEBUGLVL>=5}
      writeln('Var2StrTup S16 rawhex=', StringDumpToHex(source));
      {$endif}
      TmpUtfStr := TTwoCharStringToRawString (source);
      Result.str:= Utf8String_To_EscapedUtf8String( TmpUtfStr ); //convert widetring to UTF8!
      exit(Result);
    end;
    if (Result.var_type = varString) then
    begin
      {$if DEBUGLVL>=5}
      writeln('Var2StrTup S8 rawhex=', StringDumpToHex(source));
      {$endif}

      Result.str:= Utf8String_To_EscapedUtf8String( source); //handle escape sequences for the string.
      exit(Result);
    end;


    if Result.var_type = varnull then
    begin
      Result.str:=NULL_STR;
      exit(Result);
    end;
    if (Result.var_type = varDate) then
    begin
      var_date:=VarToDateTime(source);
      Result.str:=DateTimeToStr(var_date,DefaultFileFormatSettings); //Uses internal fixed regional settings (
      exit(Result);
    end;
    if (Result.var_type = varsingle) or
       (Result.var_type = vardouble) then
    begin
      val:=Source;
      Result.str:=FloatToStr(val,DefaultFileFormatSettings);
      exit(Result);
    end;

    Result.str:=VarToStr(source);
    //For some types VarToStr returns an empty string this is converted into a null type and matching string
    if Result.Str = '' then
    begin
      Result.var_type := varnull;
      Result.str:=NULL_STR;
      exit(Result);
    end;
  end;


function SyncStr(self_InternalUseSync:boolean):TUTF8String;
begin
  if self_InternalUseSync then Result:=STREAMSTRING_SYNC else Result:='';
end;

function TStreamStringParserTagSupport.TagAbstractTypeToText(AbstractTagType : TTagtypeSet) :TUTF8String;
begin
  case AbstractTagType of
  TT_Undefined:           Result:='TT_Undefined';
  TT_GlobalHeader:        Result:='TT_GlobalHeader';
  TT_FormHeader:          Result:='TT_FormHeader';
  TT_Item:                Result:='TT_Item';
  TT_RecordHeader:        Result:='TT_RecordHeader';
  TT_Recordpointer_ref:   Result:='TT_Recordpointer_ref';
  TT_Formpointer_ref:     Result:='TT_Formpointer_ref';
  TT_Globalpointer_ref:   Result:='TT_Globalpointer_ref';
  TT_GlobalItem:          Result:='TT_GlobalItem';
  TT_FormItem:            Result:='TT_FormItem';
  TT_GlobalEnd:           Result:='TT_GlobalEnd';
  TT_FormEnd:             Result:='TT_FormEnd';
  TT_ItemEnd:             Result:='TT_ItemEnd';
  TT_RecordEnd:           Result:='TT_RecordEnd';
  TT_extension:           Result:='TT_extension';
  TT_ArrayStart:          Result:='TT_ArrayStart';
  TT_ArrayEnd:            Result:='TT_ArrayEnd';
  otherwise
    Result:='Unknown type';
    {$if DEBUGLVL>=1}
    log.LogWarning('Unknown Abstract tag type detected.' + IntToHex(uint8(AbstractTagType)), INFOLINE , {$i %line%});
    {$endif}
  end;
end;

//function TStreamStringParserTagSupport.TagToStreamString(source:TTagData; var errors:TStringConvError):TUTF8String;
function TStreamStringParserTagSupport.TagToStreamString(source:TTagData):TResUTF8String;

//type
//
//  TTagId_small = Uint16;
//  TTagUserType_small = Uint8;
//  TTagIndex_small = Uint8;
//
//  TTagData_small = Record
//    TagsId          : TTagId_small; //individual item in file has a unique ID
//    TagsUserType    : TTagUserType_small; //What type is this item
//    TagAbstractType : TTagIndex_small; //What part of the filestructure does this part belong to? See TTagtypeSet
//    Value           : variant; //Actual value stored
//  end;
//
//  TTagId_medium1 = Uint32;
//  TTagUserType_medium1 = Uint8;
//  TagAbstractType_medium1 = Uint8;
//
//  TTagData_medium1 = Record
//    TagsId          : TTagId_medium1; //individual item in file has a unique ID
//    TagsUserType    : TTagUserType_medium1; //What type is this item
//    TagAbstractType : TagAbstractType_medium1; //What part of the filestructure does this part belong to? See TTagtypeSet
//    Value           : variant; //Actual value stored
//  end;
//
//
//  TTagId_medium2 = Uint32;
//  TTagUserType_medium2 = Uint16;
//  TagAbstractType_medium2 = Uint16;
//
//  TTagData_medium2 = Record
//    TagsId          : TTagId_medium2; //individual item in file has a unique ID
//    TagsUserType    : TTagUserType_medium2; //What type is this item
//    TagAbstractType : TagAbstractType_medium2; //What part of the filestructure does this part belong to? See TTagtypeSet
//    Value           : variant; //Actual value stored
//  end;
//
//  TTagId_large = Uint64;
//  TTagUserType_large = Uint16;
//  TagAbstractType_large = Uint8;
//
//  TTagId = TTagId_large ;
//  TTagUserType = TTagUserType_large;
//
//  p_TTagData = ^TTagData;
//  TTagData = Record
//    TagsId          : TTagId; //individual item in file has a unique ID
//    TagsUserType    : TTagUserType; //What type is this item
//    TagAbstractType : TTagtypeSet; //What part of the filestructure does this part belong to? See TTagtypeSet
//    Value           : variant; //Actual value stored
//  //    RecPtr          : Pointer;//Used only for storing pointers to the beginning of a record/Form/Global
//    //Index          : TTagIndex; //Used only for storing index of the stored record/Form/Global in a variable array
//  end;
//  TTagData_large = TTagData;
//
//  TTagArray = array of TTagdata;



function TagDataSizeNeeded(source:TTagData):TTagSizeStruct;
begin
  if (source.TagsId <= MAXValue16Bit) and
     (source.TagsUserType = 0) and
     (source.TagAbstractType =0) then exit( TagSizeNano);
  if (source.TagsId <= MAXValue16Bit) and
     (source.TagsUserType = 0) and
     (source.TagAbstractType <= MAxValue8Bit) then exit( TagSizeMicro);
  if (source.TagsId <= MAXValue16Bit) and
     (source.TagsUserType <= MAxValue8Bit) and
     (source.TagAbstractType <= MAxValue8Bit) then exit( TagSizeSmall);
  if (source.TagsId <= MAXValue32Bit) and
     (source.TagsUserType <= MAxValue8Bit) and
     (source.TagAbstractType <= MAxValue8Bit) then exit(TagSizeMedium1);
  if (source.TagsId <= MAXValue32Bit) and
    (source.TagsUserType <= MAxValue16Bit) and
    (source.TagAbstractType <= MAxValue8Bit) then exit(TagSizeMedium2);
  result := TagSizeLarge;
end;

var
    UserIdStr, UserTypeStr, MetaTypeStr , ToConvert: TUTF8String;
    ActualTagSize:TTagSizeStruct;

begin
  ActualTagSize := TagDataSizeNeeded(source);
  UserIdStr   := IntToHex(source.TagsId, ActualTagSize.IdSize);
  if ActualTagSize.UserTypeSize = 0 then UserTypeStr:='' else UserTypeStr := IntToHex(source.TagsUserType, ActualTagSize.UserTypeSize);
  if ActualTagSize.MetaTypeSize = 0 then MetaTypeStr:='' else MetaTypeStr := IntToHex(uint8( source.TagAbstractType), ActualTagSize.MetaTypeSize);

  ToConvert   := UserIdStr + UserTypeStr + MetaTypeStr;
//  writeln('ToConvert UserIdStr=', UserIdStr, ' UserTypeStr=',UserTypeStr,' MetaTypeStr=',MetaTypeStr);

//check for size and choose injected size
  Result      := self.VariantToStreamString_(source.Value, ToConvert , ActualTagSize.TagSize );

  {$if DEBUGLVL >= 3}
  log.LogStatus('TagToStreamString(' +
                 self.TagAbstractTypeToText(TTagtypeSet( source.TagAbstractType)) +') = "'+
                 Result+'" & ToConvert ="'+ToConvert+'"', INFOLINE , {$i %line%});
  {$endif}
end;

function TStreamStringParserTagSupport.ItemToStreamString(Source:Variant):TResUTF8String;
begin
  Result:=self.VariantToStreamString(source);
end;

function TStreamStringParserTagSupport.ItemToStreamString(Source:TTagdata):TResUTF8String;
begin
  Result:=self.TagToStreamString(source);
end;

//procedure StreamStringToItem(streamstring:UTF8String; VarExpectedType:TvartypeSet; var dest:TResTagData);
//procedure StreamStringToItem(streamstring:UTF8String; VarExpectedType:TvartypeSet; var dest:TResVariant);
procedure TStreamStringParserTagSupport.StreamStringToItem(streamstring:UTF8String; VarExpectedType:TvartypeSet;var dest:TResTagData);
begin
  dest := self.StreamStringToTaggedVariant(streamstring, VarExpectedType);
end;

procedure TStreamStringParserTagSupport.StreamStringToItem(streamstring:UTF8String; VarExpectedType:TvartypeSet; var dest:TResVariant);
var
    res:TResTagData;
begin
  res  := self.StreamStringToTaggedVariant(streamstring, VarExpectedType); //This function also handles streamstrings with no injection as well as strings with tags injected
  if res.Success then
    dest.SetResult(res.Result.Value)
  else
    dest.SetFailure(res.Error);
end;

Function TStreamStringParserTagSupport.GetNextID:Uint32;
begin
  if self.LastId < $FFFFFFFE then
  begin
    self.LastId:=self.LastId +1;
    Result := Self.LastId;
  end
  else
  begin
    {$if DEBUGLVL >= 1}
    log.LogError('LastId value higher than maximum allowed: $FFFFFFFF. Resetting to 0 (i.e. LastId is NOT unique)', INFOLINE , {$i %line%});
    {$endif}
    self.LastId:=0;
  end;
end;

procedure TStreamStringParserTagSupport.ResetIdCounter;
begin
  self.LastId:=0;
end;

function InitTag:TTagData;
begin
  Result.TagsId:= 0;
  Result.TagsUserType:=0;
  Result.TagAbstractType:=Uint8(TT_Undefined) and $FF;
  Result.Value := NaN;
  //Result.Index:= 0;
end;


//procedure TStreamStringParserTagSupport.InitTag(var tag:TTagData);
//begin
//  Tag:= InitTag;
//end;

procedure TStreamStringParserTagSupport.InitTag_;
begin
   self.TagData:= InitTag;
end;

Procedure TStreamStringParserTagSupport.PostParseHandler(VarValue:Variant; var ErrorCode:TStringConvError);
Begin
  self.TagData.Value:=VarValue;
end;

function TStreamStringParserTagSupport.injectionhandler(PayloadId:char; InjectedPayload:UTF8String):TInjectionErrors;
{
TT_Undefined           =       0; ///< A tag is not properly defined (from fileread (the reader will recover as much data as possible)
TT_GlobalHeader        =       1; ///< A global definition. This has to be at the start of a file. All later global tags are ignored after the first TTagType of any other type..
TT_FormHeader          =       2; ///< A form is a collection of records (TT_tems defined immediatley after are considered local variables for the form and records within the form
TT_Item                =       3; ///< A single item is a tag as part of something larger e.g. a record
TT_RecordHeader        =       4; ///< A start of a record. Value is the type name for the record type, TagId is an autogenerated replacement for the pointer to the record
TT_Recordpointer_ref   =       5; ///< A reference to pointer to a record (only pointer to records are allowed now)
TT_Formpointer_ref     =       6; ///< A reference to pointer to a form (only pointer to records are supported for now)
TT_Globalpointer_ref   =       7; ///< A reference to pointer to a Global (only pointer to records are supported now)
TT_GlobalEnd           = 128 + 1; ///< End of global header
TT_FormEnd             = 128 + 2; ///< End of form
TT_ItemEnd             = 128 + 3; ///< End of complex item (Not used)
TT_RecordEnd           = 128 + 4; ///< End of record
TT_extension_V1Type    = 255;     ///<

}
var
    undefined_value:uint8;
    pos,errorpos : integer;
    TagSizeData:TTagSizeStruct;
    CombinedSizeNeeded :integer;
    ResTagsId : TResValUint64;
    ResTagAbstractType : TResValUint8;
    ResTagsUserType : TResValUint16;

    //A char (InjectID) tells the size of tag for the individual fields
    function TagDataSizeNeeded(InjectId:Char):TTagSizeStruct;
    begin
      if InjectId =TTagSizeNano then exit( TagSizeNano );
      if InjectId =TTagSizeMicro then exit( TagSizeMicro );
      if InjectId =TTagSizeSmall then exit( TagSizeSmall );
      if InjectId =TTagSizeMedium1 then exit( TagSizeMedium1 );
      if InjectId =TTagSizeMEdium2 then exit( TagSizeMedium2 );
      Result := TagSizeLarge;
    end;

begin
  self.InitTag_;

  {$if DEBUGLVL >= 3}
  log.LogStatus('Injectionhandler called with InjectedPayload="'+InjectedPayload+'"', INFOLINE , {$i %line%});
  {$endif}

  if CharPosInString(PayloadId, InjectedIdTaggedChars,1) < 0 then //is it in the list of known IDs
//  if (PayloadId <> InjectId_Tag_small) then
  begin
    {$if DEBUGLVL>=1}
    log.LogError('Injectionhandler called with wrong PayloadId="'+PayloadId+'", <> "'+InjectId_Tag_small+'"', INFOLINE , {$i %line%});
    {$endif}
    exit(IERR_Unknown_ID);
  end;
  TagsizeData := TagDataSizeNeeded(PayloadId);
  CombinedSizeNeeded:= TagSizeData.IdSize +
                       TagSizeData.UserTypeSize +
                       TagSizeData.MetaTypeSize;
  if length(InjectedPayload) <> CombinedSizeNeeded then
  begin
    {$if DEBUGLVL>=1}
    log.LogError('Injectionhandler called with wrong expected TagInjectedSize="'+ IntToStr(CombinedSizeNeeded)+'", <> length="' + IntToStr(length(InjectedPayload))+'"', INFOLINE , {$i %line%});
    {$endif}
    exit(IERR_PayloadError);
  end;

  pos :=1;
  errorpos := 0;
//  self.TagData.TagsId := HexToUInt64(Copy(InjectedPayload, pos, TagSizeData.IdSize) , errorpos);
  ResTagsId := HexToUInt64(Copy(InjectedPayload, pos, TagSizeData.IdSize) );
  if ResTagsId.Success then
  begin
    self.TagData.TagsId := ResTagsId.Result;
  end
  else
  begin
    {$if DEBUGLVL >= 1}
    log.LogError('Conversion error on tagsid pos='+ ResTagsId.Error.ErrorStr +' , size='+ IntToStr(TagSizeData.IdSize)  , INFOLINE , {$i %line%});
    {$endif}
    exit(IERR_PayloadError);
  end;
  //{$if DEBUGLVL >= 2}
  //writeln('Tagsid=', self.TagData.TagsId);
  //{$endif}

  pos += TagSizeData.IdSize;
  if TagSizeData.UserTypeSize > 0 then
  begin
    ResTagsUserType := HexToUInt16(Copy(InjectedPayload, pos, TagSizeData.UserTypeSize));
    if ResTagsUserType.Success then
      self.TagData.TagsUserType := ResTagsUserType.Result
    else
      exit(IERR_PayloadError);
  end
  else
  begin
    self.TagData.TagsUserType:= 0;
  end;
  //{$if DEBUGLVL >= 2}
  //writeln('TagsUserType=', self.TagData.TagsUserType);
  //{$endif}
  pos += TagSizeData.UserTypeSize;
  if TagSizeData.MetaTypeSize > 0 then
  begin
    ResTagAbstractType := HexToUInt8(Copy(InjectedPayload, pos, TagSizeData.MetaTypeSize));
    if ResTagAbstractType.Success then
      self.TagData.TagAbstractType := ResTagAbstractType.Result
    else
      exit(IERR_PayloadError);
  end
  else
  begin
    self.TagData.TagAbstractType:= TT_Undefined;
  end;
  //{$if DEBUGLVL >= 2}
  //writeln('TagAbstractType=', self.TagData.TagAbstractType);
  //{$endif}
end;


//Function StreamStringToVariant(streamstring:UTF8String; VarExpectedType:TvartypeSet; var errors:TStringConvError):Variant;
function TStreamStringParserTagSupport.StreamStringToTaggedVariant(
           streamstring:UTF8String;
           VarExpectedType:TvartypeSet):TResTagData;
var
    ResVariant: TResVariant;
    err : TStringConvError;
begin
  err := SCE_ClearError;
  self.InitTag_;
  ResVariant :=self.StreamStringToVariant(streamstring, VarExpectedType);
  if ResVariant.Success then
  begin
    self.TagData.Value := ResVariant.Result;
//  Self.TagData.Index:=0; { #todo : need handling of references to pointers }
    Result.SetResult(self.TagData);
	end
  else
  begin
    err.ConvError:= SCE_Wrong_Type;
    self.SetSceError(err) ;
    Result.SetFailure( err );
	end;
end;


function VarTypeToStrId( var_type:Integer):TUTF8String;
begin
  Result:=STRID_varunknown;
  case var_type of
      varempty: result:=STRID_varempty ;
      varnull: result:=STRID_varnull ;
    {$ifndef FPUNONE}
      varsingle: result:=STRID_varsingle ;
      vardouble: result:=STRID_vardouble ;
      vardate: result:=STRID_vardate ;
    {$endif}
      varcurrency: result:=STRID_varcurrency ;
      vardispatch: result:=STRID_vardispatch ;
      varerror: result:=STRID_varerror ;
      varboolean: result:=STRID_varboolean ;
      varvariant: result:=STRID_varvariant ;
      varunknown: result:=STRID_varunknown ;
      vardecimal: result:=STRID_vardecimal ;
      varshortint: result:=STRID_varshortint ; //int8
      varbyte: result:=STRID_varbyte ;  //uint8
      varsmallint: result:=STRID_varsmallint ; //int16
      varword: result:=STRID_varword ; //uint16
      varinteger: result:=STRID_varinteger ; //int32
      varlongword: result:=STRID_varlongword ; //uint32 (also called cardinal)
      varint64: result:=STRID_varint64 ; //int64
      varqword: result:=STRID_varqword ; //Uint64
      varstring: result:=STRID_varstring ;
      varolestr: result:=STRID_varolestr ;  // may not be cross platform ? ask on forum
      varshortstring: result:= STRID_VarShortString;
  Otherwise
    begin
     result:=STRID_varunknown;
    end;
  end;
end;

/// @brief Convert variant to streamstring. Supports possible injected header of type injectedId
// @param source: variant to convert to string
// @param InjectedHeader: header (max length 254 chars) to inject into header of streamstring. Empty InjectedHeader or id=#0 means no injected header (allows support data to piggyback (used for tag support))
// @param InjectedId: Type Id of injected header. Empty InjectedHeader or id=#0 means no injected header
function TStreamStringParser.VariantToStreamString_(source:variant;
           InjectedHeader_:TUTF8String; InjectedId_:char):TResUTF8String;
var
    errors:boolean;
    tupple:TVariantStrTupple;
    InjectedHeaderLength : integer;
    header, SyncCh, token, chksum_header, chksum_payload:TUTF8String;
    SizeHex:TUTF8String;
    SizeInjected : TUTF8String;
    CRC_value : Uint32;
    HexSizeSize, PayLoadSize :UInt32;
    CkhSumVal:UInt32;
    HeaderCRCType, PayloadCRCType :TCRC_type;
    err : TStringConvError;

    function CheckSumSizeToChar ( HeaderCRCSize, PayloadCRCSize:TCRC_type): TUTF8String;
    var
        returnval:UInt8;
    begin
      Returnval := STS_CHKSZ_BASE;
      case headerCRCsize of
        Use16BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_HEADER_16;
        Use32BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_HEADER_32;
        Use64BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_HEADER_64;
        Use128BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_HEADER_128;
      end;

      case PayloadCRCSize of
        Use16BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_PAYLOAD_16;
        Use32BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_PAYLOAD_32;
        Use64BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_PAYLOAD_64;
        Use128BitCRC: ReturnVal:=ReturnVal Or STS_CHKSZ_PAYLOAD_128;
      end;
      Result:= Chr(returnval);
    end;

begin
  err := SCE_ClearError;
  {$if DEBUGLVL >= 3}
  writeln('V2Stst_ vartype = ', vartype(source));
  //write('< VariantToStreamString_ Vartype(source)=', VarType(source),' >');
  {$endif}
  Tupple:= VariantToStringTupple(source);
   token:=STRID_varunknown;
  Token := VarTypeToStrId(Tupple.var_type);
  HexSizeSize := GetSizeOfSizeBlock(tupple.var_type);
  write('/Vartype strid=', VarTypeToStrId(tupple.var_type),'/ ');
  PayLoadSize:= length(tupple.str);
  SizeHex := IntToHex(PayLoadSize, HexSizeSize); //Allows us to store up to 2GiB of binary data in a single string
  write('<variant PayLoadSize=',PayLoadSize,'> ');
  syncCh := SyncStr(self.InternalUseSync);
  InjectedHeaderLength:=length(InjectedHeader_);
  if ( (InjectedHeaderLength = 0) Or (InjectedId_ = #0)) then
  begin
    {$if DEBUGLVL >= 4}
    if (InjectedHeaderLength = 0) then write('(lenght=0)');
    if (InjectedId_ = #0) then  write('(ID=#0)');
    {$endif}
    {$if DEBUGLVL >= 3}
    writeln('No injected header');
    {$endif}
    injectedHeader := '';
  end
  else
  begin

    SizeInjected := IntToHex(InjectedHeaderLength, 2);
    InjectedHeader := STRID_VarInjectedHeader + InjectedId_ +SizeInjected + InjectedHeader_;
    {$if DEBUGLVL >= 3}
    log.LogStatus('Injected Header="' + STRID_VarInjectedHeader + InjectedId_ +SizeInjected+ '"+ payloadinjected="' + InjectedHeader_+'"', INFOLINE , {$i %line%});
    {$endif}
    {$if DEBUGLVL >= 1}
    if InjectedHeaderLength > 255 then
    begin
      err.ConvError:=SCE_length_Error;
      Result.SetFailure(err);
      {$if DEBUGLVL>=1}
      log.LogError('Injected header to large (> 255 bytes)' , INFOLINE , {$i %line%});
      {$endif}
      exit(Result);
    end;
    {$endif}
  end;

  //{$if DEBUGLVL >= 2}
  //write('SyncCh ="',SyncCh,'" Token="',token,'" SizeHex="',SizeHex,'" ,SeparatorChar="', self.SeparatorChar,'" ');
  //write('payload ="',self.EscParser.StringToESCStr(tupple.str),'"' );
  //{$endif}

  HeaderCRCType  := Use16BitCRC;

  if PayLoadSize > SMALL_PAYLOAD_SIZE then PayloadCRCType := Use32BitCRC else PayloadCRCType := Use16BitCRC;

  header := InjectedHeader + Token  + SizeHex +
            CheckSumSizeToChar ( HeaderCRCType, PayloadCRCType) +
            self.SeparatorChar ;

  //{$if DEBUGLVL >= 3}
  //writeln('chksum header based on "',header ,'"');
  //{$endif}
  chksum_header  := CrcStr(self.InternalUseChecksum, header, HeaderCRCType);
  self.EscParser.Reset;
  chksum_payload := CrcStr(self.InternalUseChecksum, tupple.str, PayloadCRCType);
  self.EscParser.Reset;
  //token & Sizehex & separatorchar is assumed contain only ASCII chars from #32 to #127 - Payload can be anything (payload is tupple.str)
  //Result:= SyncCh +  Token + SizeHex + SEPARATORCHAR + self.EscParser.StringToESCStr(tupple.str );
  self.EscParser.Reset;
  //the format is [SyncCh] + header + chksumheader + payload + chksumpayload


  Result.SetResult(SyncCh +
		               self.EscParser.StringToESCStr(header) +
		               chksum_header +
		               self.EscParser.StringToESCStr(tupple.str ) +
		               chksum_payload);


end;



//function TagSetToStreamString(tagid: Tagstring; tagvalue:variant;var errors:TStringConversionError):TUTF8String;
//var
//    idstr,valstr:TUTF8String;
//begin
//  Result:='';
//  error := SCE_ClearError;
//  idstr  := TagIdToStreamString(tagid,error);
//  if SCE_NoError(error) then
//  begin
//    valstr := VariantToStreamString(tagvalue, error);
//    Result := ASCII_UNIT_SEPARATOR + idstr + valstr;
//  end;
//end;


function TStreamStringParser.VariantToStreamString(source:UTF8String):TResUTF8String;
//var
//    TempStr:UTF8String;

begin
//  errors := SCE_ClearError;
  {$if DEBUGLVL >= 4}
  Write ('< VariantToStreamString : UTF8String>');
  {$endif}
  Result:=variantToStreamString_(source,'', #0 );

  //{$if DEBUGLVL >= 3}
  //writeln('VariantToStreamString Unicode res:="', Result,'"');
  //{$endif}
end;

function TStreamStringParser.VariantToStreamString(source:TUnicodeString):TResUTF8String;
//var
//    TempStr:UTF8String;

begin
  //errors:= SCE_ClearError;
  {$if DEBUGLVL >= 4}
  Write ('< VariantToStreamString : WideString>');
  {$endif}
//  Result := variantToStreamString_(UTF8Encode(source),'', #0);
  Result:=variantToStreamString_(source,'', #0);

  //{$if DEBUGLVL >= 2}
  //writeln('VariantToStreamString Widestring res:="', Result,'"');
  //{$endif}
end;

function TStreamStringParser.VariantToStreamString(source:variant):TResUTF8String;
begin
  //{$if DEBUGLVL >= 3}
  //writeln('V2StSt vartype = ', vartype(source));
  //{$endif}
  {$if DEBUGLVL >= 4}
  Write ('< VariantToStreamString : <other> >');
  {$endif}

  Result:=VariantToStreamString_(source,'', #0);
  //{$if DEBUGLVL >= 2}
  //writeln('VariantToStreamString variant res:="', Result,'"');
  //{$endif}
end;


function StringDumpToHex(instr:TUnicodeString):TUTF8String;
var idx :integer;
begin
  if instr = '' then exit('<Empty>') else Result:='l='+IntToString(length(instr))+' ';
  for idx:=1 to Length(instr) do Result:= Result + '.' + IntToHex(UInt8(instr[idx]),4);
  Result:= Result + ' ';
end;

function StringDumpToHexUTF8(instr:UTF8String):TUTF8String;
var idx :integer;
begin
  if instr = '' then exit('<Empty>') else Result:='l='+IntToString(length(instr))+'.  ';
  for idx:=1 to Length(instr) do Result:= Result + ':' + IntToHex(UInt8(instr[idx]),2);
  Result:= Result + ' ';
end;

function StringDumpToHex(instr:TUTF8String):TUTF8String;
var idx :integer;
begin
  if instr = '' then exit('<Empty>') else Result:='l='+IntToString(length(instr))+' ';
  for idx:=1 to Length(instr) do Result:= Result + ':' + IntToHex(UInt8(instr[idx]),2);
  Result:= Result + ' ';
end;

//-------------------------

function ValToUInt64(ValStr:TUTF8String; var errorpos:integer):UInt64;
begin
  Result:= 0;
  Val (Valstr,Result,errorpos);
  If errorpos<>0 then
  begin
    Result:= $0BADFEEDDEADBEEF;
    {$if DEBUGLVL >= 1}
    log.LogError('Error at position ' + IntToStr( errorpos) +' : "' +ValStr[errorpos] + '" in "' + ValStr +'"' , INFOLINE , {$i %line%});
    {$endif}
  end;
  //else
  //begin
  //  {$if DEBUGLVL >= 2}
  //  Writeln ('Value : ',Result);
  //  {$endif}
  //end;
end;

function ValToUint32(ValStr:TUTF8String; var errorpos:integer):UInt32;
begin
  Result:= uint32( ValToUInt64 (ValStr, ErrorPos) And $FFFFFFFF);
end;
function ValToUint16(ValStr:TUTF8String; var errorpos:integer):UInt16;
begin
  Result:= uint16( ValToUInt64 (ValStr, ErrorPos) And $FFFF);
end;
function ValToUint8(ValStr:TUTF8String; var errorpos:integer):UInt8;
begin
  Result:= uint8( ValToUInt64 (ValStr, ErrorPos) And $FF);
end;

//-----------------------------

function HexToUInt64(hexstr:TUTF8String; var errorpos:integer):UInt64;
begin
  Result:= ValToUInt64('$' + hexstr , errorpos);
end;
function HexToUInt32(hexstr:TUTF8String; var errorpos:integer):UInt32;
begin
  Result:= ValToUInt32('$' + hexstr , errorpos);
end;
function HexToUInt16(hexstr:TUTF8String; var errorpos:integer):UInt16;
begin
  Result:= ValToUInt16('$' + hexstr , errorpos);
end;
function HexToUInt8(hexstr:TUTF8String; var errorpos:integer):UInt8;
begin
  Result:= ValToUInt8('$' + hexstr , errorpos);
end;

(*
TResValUint8 = specialize TGenResult<Uint8, TStringConvError>;
TResValUint16 = specialize TGenResult<Uint16, TStringConvError>;
TResValUint32 = specialize TGenResult<Uint32, TStringConvError>;
TResValUint64 = specialize TGenResult<Uint64, TStringConvError>;
TResValint8 = specialize TGenResult<int8, TStringConvError>;
TResValint16 = specialize TGenResult<int16, TStringConvError>;
TResValint32 = specialize TGenResult<int32, TStringConvError>;
TResValint64 = specialize TGenResult<int64, TStringConvError>;
TResValFloat = specialize TGenResult<Single, TStringConvError>;
TResValDouble = specialize TGenResult<Double, TStringConvError>;
TResValSingle = specialize TGenResult<Single, TStringConvError>;
TResValTDateTime = specialize TGenResult<TDateTime, TStringConvError>;
TResValBoolean = specialize TGenResult<Boolean, TStringConvError>;
TResValCurrency = specialize TGenResult<Currency, TStringConvError>;
*)



//lav generisk funktion til at hjælpe med konverteringen
//
//Dette er et eksempel fra https://forum.lazarus.freepascal.org/index.php?topic=45839.0

generic function ConvertToVariantRes<T>(source_str:UTF8String):TResVariant; // << declare the element type, not the whole array
  //var item: T;
  //begin
  //  for item in sarr do write(item, ',');
  //  writeln;
  //end;
var tmp_item:T;
    tmp_res:TResVariant;
begin
  tmp_item  := StringToType (source_str);
  if tmp_item.Success then
  begin
    tmp_res.SetResult(tmp_item.Result);
  end
  else
  Begin
   tmp_res.SetFailure(tmp_item.Error);
	end;
  Result := tmp_res;
end;


function TstreamStringParser.StringTuppleToVariant(const source:TVariantStrTupple):TResVariant;


const
    TypeKnown_ = True;
    TypeUnknown_ = False;

var err:TStringConvError;
    TmpResult : Variant;
    TempStr:TResUnicodeString;
    TempRes:TResVariant;
    test:variant;
    IsTypeKnown:Boolean;

    tmp_uint8:TResValUint8;
	  tmp_uint16:TResValUint16;
	  tmp_uint32:TResValUint32;
	  tmp_uint64:TResValUint64;
	  tmp_int8:TResValint8;
	  tmp_int16:TResValint16;
	  tmp_int32:TResValint32;
	  tmp_int64:TResValint64;
	  tmp_float:TResValFloat;
	  tmp_double:TResValDouble;
	  tmp_single:TResValSingle;
	  tmp_datetime:TResValTDateTime;
	  tmp_bool:TResValBoolean;
	  tmp_currency:TResValCurrency;
    tmp_str_utf8:TResUTF8String;
    tmp_str_unicode:TResUnicodeString;

begin
  TmpResult:=Null; //Null-variant
  err.ConvError:= SCE_NoError;
  {$if DEBUGLVL >= 4}
  writeln('*-* StringTuppleToVariant: source.var_type=', source.var_type , ' of "', source.str,'" *-*');
  {$endif}
  if source.var_type = varOleStr then
  begin
    {$if DEBUGLVL >= 4}
    writeln('Strtup2Var rawhex=', StringDumpToHex(source.str));
    {$endif}
    //TempStr :=  RawstringToTTwoCharString( EscapedUtf8String_To_Utf8String(source.str)); //Converts UTF8 string to TTwoCharString (unicode 16)
    //if TempStr.Success then
    //  TempRes.SetResult(TempStr.Result)
    //else
    //  TempRes.SetFailure(TempStr.Error);
    //
    //exit(TempRes);
    //write('OLE Raw:"', Result,'" ');
    TmpResult :=  RawstringToTTwoCharString( EscapedUtf8String_To_Utf8String(source.str)); //Converts UTF8 string to TTwoCharString (unicode 16)
    Result.SetResult(TmpResult);
    exit(Result);
  end;
  if source.var_type = varnull then
  begin
    Result.SetResult(source.str); //Null contains '(Null)'
    exit(Result);
  end;

  err.ClearError;
	case source.var_type of
    varShortInt: Begin
      //Result := ConvertToVariantRes<(;
      Result:= specialize ConvertToVariantRes<TResValint8>(source.str);
      //tmp_int8  := StringToInt8    (source.str);
      //if tmp_int8.Success then TmpResult:= tmp_int8.Result else err:= tmp_int8.Error;
		end;
		varsmallint:
      begin
        //tmp_int16 := StringToInt16   (source.str);
        Result:= specialize ConvertToVariantRes<TResValint16>(source.str);

			end;
    great success
		varInteger:   tmp_int32 := StringToInt32   (source.str);
    varInt64:     tmp_int64 := StringToInt64   (source.str);

    varByte:      tmp_uint8 := StringToUInt8   (source.str);
    varWord:      tmp_uint16 := StringToUInt16  (source.str);
    varLongWord:  tmp_uint32 := StringToUInt32  (source.str);
    varQWord:     tmp_uint64 := StringToUint64  (source.str);

    varSingle:    tmp_float := StringToSingle  (source.str);
    varDouble:    tmp_double := StringToDouble  (source.str);

    varDATE:      tmp_datetime := StringToDate    (source.str);
    varCurrency:  tmp_currency := StringToCurrency(source.str);
    varBoolean:   tmp_bool := StringToBoolean (source.str);
    varString:    tmp_str_utf8 := EscapedUtf8String_To_Utf8String (source.str);
	  ////    varOleStr:    Result := StringToOleStr(source.str); //Converts UTF8 string to TTwoCharString (unicode 16)
	  //    varOleStr:
  Otherwise
    begin
      Result.SetFailure(SCE_unknown_linetype);
      //err.ConvError:=SCE_unknown_linetype;
      //TmpResult := 'Error in vartype('+ IntToString( source.var_type) + ') in ' + source.str;
    end;
  end;
  //if SCE_HasErrors(err) then
  //   Result.SetFailure(err)
  //else
  //   Result.SetResult(TmpResult);
  exit(result);
end;

Function TvartypeSet_to_VariantTypeType(vartype:TvartypeSet):Uint16;
begin
  Result:= varerror;
  case vartype of
    vt_empty:      Result:=  varempty;
    vt_null:       Result:=  varnull;
    {$ifndef FPUNONE}
    vt_single:     Result:=  varsingle;
    vt_double:     Result:=  vardouble;
    vt_date:       Result:=  vardate;
    {$endif}
    vt_currency:   Result:=  varcurrency;
    vt_olestr:     Result:=  varolestr;
    vt_dispatch:   Result:=  vardispatch;
    vt_error:      Result:=  varerror;
    vt_boolean:    Result:=  varboolean;
    vt_variant:    Result:=  varvariant;
    vt_unknown:    Result:=  varunknown;
    vt_decimal:    Result:=  vardecimal;
    vt_int8:       Result:=  varshortint;
    vt_uint8:      Result:=  varbyte;
    vt_int16:      Result:=  varsmallint;
    vt_uint16:     Result:=  varword;
    vt_int32:      Result:=  varinteger;
    vt_uint32:     Result:=  varlongword;
    vt_int64:      Result:=  varint64;
    vt_uint64:     Result:=  varqword;
    vt_string:     Result:=  varstring;
  otherwise
      Result:=varerror;
  end;

end;

Function VariantTypeType_to_TvartypeSet(vartype:uint16):TvartypeSet;
begin
  Result:= vt_error;
  case vartype of
    varempty:     Result:= vt_empty;
    varnull:      Result:= vt_null;
    {$ifndef FPUNONE}
    varsingle:    Result:= vt_single;
    vardouble:    Result:= vt_double;
    vardate:      Result:= vt_date;
    {$endif}
    varcurrency:  Result:= vt_currency;
    varolestr:    Result:= vt_olestr;
    vardispatch:  Result:= vt_dispatch;
    varerror:     Result:= vt_error;
    varboolean:   Result:= vt_boolean;
    varvariant:   Result:= vt_variant;
    varunknown:   Result:= vt_unknown;
    vardecimal:   Result:= vt_decimal;
    varshortint:  Result:= vt_int8;
    varbyte:      Result:= vt_uint8;
    varsmallint:  Result:= vt_int16;
    varword:      Result:= vt_uint16;
    varinteger:	  Result:= vt_int32;
    varlongword:  Result:= vt_uint32;
    varint64:     Result:= vt_int64;
    varqword:     Result:= vt_uint64;
    varstring:    Result:= vt_string;
  otherwise
      Result:=vt_error;
  end;
end;

function Ident_to_varianttype(var_type:char):Uint16;
begin
  Result:=varerror;
  //{$if DEBUGLVL >= 3}
  //write('{ident="', var_type,'"}');
  //{$endif}
  case var_type of
    STRID_varempty:      Result:= varempty;
    STRID_varnull:       Result:= varnull;
    {$ifndef FPUNONE}
    STRID_varsingle:     Result:= varsingle;
    STRID_vardouble:     Result:= vardouble;
    STRID_vardate:       Result:= vardate;
    {$endif}
    STRID_varcurrency:   Result:= varcurrency;
    STRID_varolestr:     Result:= varolestr;
    STRID_vardispatch:   Result:= vardispatch;
    STRID_varerror:      Result:= varerror;
    STRID_varboolean:    Result:= varboolean;
    STRID_varvariant:    Result:= varvariant;
    STRID_varunknown:    Result:= varunknown;
    STRID_vardecimal:    Result:= vardecimal;
    STRID_varshortint:   Result:= varshortint;
    STRID_varbyte:       Result:= varbyte;
    STRID_varsmallint:   Result:= varsmallint;
    STRID_varword:       Result:= varword;
    STRID_varinteger:    Result:= varinteger;
    STRID_varlongword:   Result:= varlongword;
    STRID_varint64:      Result:= varint64;
    STRID_varqword:      Result:= varqword;
    STRID_varstring:     Result:= varstring;
  Otherwise
    begin
      Result:=varerror;
    end;
  end;
end;

function ident_to_TvartypeSet(ident:char):TvartypeSet;
begin
  result:=VariantTypeType_to_TvartypeSet(Ident_to_varianttype(ident));
end;


function TStreamStringParser.StreamStringToVariantTupple(source:TUTF8String):TResVariantTupple;
var
    idx:integer;
  Res :TVariantTupple;
begin
  self.ResetState;
  for idx:= 1 to length(source) do
  begin
    self.UpdateStateMachine(source[idx]);
  end;
  if (not SCE_NoErrors(self.InternalError)) OR
     (self.ReceivedType = vt_error) then //Error detected during conversion
  begin
    Res.ID:=vt_error;
    Res.value:=0;
    REsult.SetFailure'(self.InternalError);
    exit(Result);
  end;
  Res.ID:=self.ReceivedType;
  Res.value:=self.payload;
  Result.SetResult(Res);
end;

//function TStreamStringHandler._IsFileOpen:boolean;
//begin
//  if (self.OpenForRead or self.OpenForWrite) and (not(self.UseStream)) then
//    Result := True
//  else
//    Result := False;
//end;

function TStreamStringHandler._IsStreamOpen:boolean;
begin
//  if (self.OpenForRead or self.OpenForWrite) and self.UseStream then
  if (self.OpenForRead or self.OpenForWrite)  then
    Result := True
  else
    Result := False;
end;

function TStreamStringHandler.OpenStreamForRead( filename:TUTF8String):boolean;
begin
  Result:=False;
  if IsStreamOpen then CloseStream;
  try
    self.WriteOpen:=False;

    self._CurrentStream := TFileStream.Create(filename, fmOpenRead, fmShareDenyWrite );
    self.CurrentStreamName := filename;
    //rstream:=TFileStream.Create(filename, fmOpenRead);
    self.WriteOpen:=False;
    self.ReadOpen:=True;
    self.StreamUse:=True;
    Result:=true;
    write('Stream is opened for read = ', self.ReadOpen,'  ');
  except
    on E: Exception do
    begin
      self.SetSceError(SCE_IOerror_StreamCreate_read_Error);
      {$if DEBUGLVL>=1}
        log.LogError( 'SCE_IOerror_StreamCreate_read_Error :'+ e.ToString, INFOLINE , {$i %line%});
      {$endif}
      writeln('---*** EXCEPTION in opening stream for read!!!! ***---');
      Result:=False;
    end;
  end;
end;

function TStreamStringHandler.OpenStreamForWrite( filename:TUTF8String; NewFile:boolean):boolean;
//soFromBeginning = 0;
//soFromCurrent = 1;
//soFromEnd = 2;

begin
  Result:=True;
  if self.IsStreamOpen then self.CloseStream;
  try
    if NewFile then
    begin  //Allow other processes to read our file at the same time
      try
        self._CurrentStream := TFileStream.Create(filename, fmCreate, fmShareDenyWrite );
        self.CurrentStreamName := filename;
        self.ReadOpen:=False;
        self.WriteOpen:=True;
        self.IsStreamOpen;
      except
        on E: Exception do
        begin
          self.SetSceError(SCE_IOerror_StreamCreate_write_Error);
          {$if DEBUGLVL>=1}
          log.LogError( 'Create new stream failed. SCE_IOerror_StreamCreate_write_Error :'+ e.ToString, INFOLINE , {$i %line%});
          {$endif}
          Result:=False;
        end;
      end;
    end
    else
    begin
      try
        self._CurrentStream := TFileStream.Create(filename, fmOpenWrite, fmShareDenyWrite );
        self.CurrentStreamName := filename;
        StreamSeek( 0, soEnd);
      except
        on E: Exception do
        begin
          self.SetSceError(SCE_IOerror_StreamCreate_write_Error);
          {$if DEBUGLVL>=1}
          log.LogError( 'Create new stream failed. SCE_IOerror_StreamCreate_write_Error :'+ e.ToString, INFOLINE , {$i %line%});
          {$endif}
          Result:=False;
        end;
      end;
      if SCE_HasErrors(self.Error) then
      Begin
        self.SetSceError(SCE_IOerror_StreamCreate_write_Error);
        {$if DEBUGLVL>=1}
        log.LogError( 'SCE_IOerror_StreamCreate_write_Error : Could not seek to end', INFOLINE , {$i %line%});
        {$endif}
        Result:=False;
      end;
    end;
    self.ReadOpen:=False;
    self.WriteOpen:=True;
  except
    on E: Exception do
    begin
      self.SetSceError(SCE_IOerror_StreamCreate_write_Error);
      {$if DEBUGLVL>=1}
      log.LogError( 'SCE_IOerror_StreamCreate_write_Error :'+ e.ToString, INFOLINE , {$i %line%});
      {$endif}
      Result:=False;
    end;
  end;
end;

procedure TStreamStringHandler.CloseStream;
begin
  if IsStreamOpen then
  begin
    try
      self._CurrentStream.Free;
      self.UseStream:=False;
      self.ReadOpen:=False;
      self.WriteOpen:=False;
    except
      on E: Exception do
      begin
        self.SetSceError(SCE_IOerror_StreamClose_Error);
        {$if DEBUGLVL>=1}
        log.LogError( 'SCE_IOerror_StreamClose_Error :'+ e.ToString, INFOLINE , {$i %line%});
        {$endif}
      end;
    end;
  end;
end;

function TStreamStringHandler.GetStreamSize:int64;
begin
  if IsStreamOpen then
  try
    Result := self._CurrentStream.Size;
  except
    on E: Exception do
    begin
      self.SetSceError(SCE_IOerror_StreamSize_Error);
      {$if DEBUGLVL>=1}
      log.LogError( 'SCE_IOerror_StreamSize_Error :'+ e.ToString, INFOLINE , {$i %line%});
      {$endif}
    end;
  end;
end;

function TStreamStringHandler.StreamSeek(offset: int64; Origin:TSeekOrigin):int64;
begin
  Result:=0;
  if IsStreamOpen then
  try
    Result:=self._CurrentStream.Seek(offset, Origin);
  except
    on E: Exception do
    begin
      self.SetSceError(SCE_IOerror_StreamSeek_Error);
      {$if DEBUGLVL>=1}
      log.LogError( 'SCE_IOerror_StreamSeek_Error :'+ e.ToString, INFOLINE , {$i %line%});
      {$endif}
    end;
  end;
end;

function TStreamStringHandler.ReadVariantTupplefromStream(AStream:TStream):TResVariantTupple;

var
    idx:integer;
    ch:char;
    res:TVariantTupple;

begin
  self.ResetState;

  self.InitTag_;
  repeat
    try
      ch := char(Astream.ReadByte);
      {$if DEBUGLVL >= 4}
      write('[', ch,'] ');
      {$endif}
      self.UpdateStateMachine(ch);
    except
      on E: Exception do
      begin
        //writeln('Exception (',e.ToString,') ');
        self.InternalError.ConvError:=SCE_IOerror_Read_Error;
        //ErrorCode:=self.InternalError;
        {$if DEBUGLVL>=1}
        log.LogError( 'SCE_IOerror_Read_Error :'+ e.ToString, INFOLINE , {$i %line%});
        {$endif}
      end;
    end;
  until ((self.IsDone) or (self.HasError));

  if self.HasError then
  begin
    Result.SetFailure(self.InternalError);
    exit(Result);
  end;
  Res.ID:=self.ReceivedType;
  Res.value:=self.payload;
  self.TagData.Value:=Res.Value;
  Result.SetResult(res);
end;

constructor TStreamStringHandler.Create;
begin
  inherited create;
  self.LastId:=0;
end;

destructor TStreamStringHandler.Destroy;
begin
  //sp.Destroy;
  if self.IsStreamOpen then self.CloseStream;
  inherited Destroy;
end;

function TStreamStringHandler.ParseString(Source:TUTF8String;
                                          Var Value:TTagData;
                                          var FoundItem:boolean):TResUTF8String;
var
  backtrack_pos,
  idx:UInt64;

  State: TStreamstringParserState;
  warning: boolean;

  function IsReallyDone(errorcode:TStringConversionError; IsDone:boolean):Boolean;
  begin
    Result := IsDone;
    if SCE_HasErrors(errorcode) then Result:=False;
  end;

begin
  {$if DEBUGLVL >= 4}
  write('<ParseString ("',source,'")>');
  write ('sync =', self.InternalUseSync, ' use CRC=', self.InternalUseChecksum);
  {$endif}
  self.ResetState;
  idx:=1;
  warning := False;
  value := InitTag;
  //fix parsestring so a Checksum error leads to a search for the next checksum marker if possible
  //problem is now that it cannot escape CRC errors
  while (not IsReallyDone(self.error, self.IsDone)) and
//        (SCE_NoErrors(self.Error)) and
        (idx <= length(Source)) do
  begin
    state:=self.UpdateStateMachine(Source[idx]);
    if state = SPS_GetSync then
    begin
      backtrack_pos := idx +1; //If we find a syncmarker that has erroneous header or load connected to it, means that we may have had a false sync. So we backtrack later, but makes sure that we still progress forward in the string.
      {$if DEBUGLVL >= 4}
      write('{SPS_GetSync: Backtrack to ' + inttostr(backtrack_pos)+'} ');
      {$endif}
    end;
      //if ((self.Error.ConvError = SCE_Checksum_Error) Or
    //    (self.Error.ConvError = SCE_length_Error)) then //if a checksum/length error occurs , we enable further reads if sync is enabled (otherwise no way to resynchronize)
    if (self.Error.ConvError = SCE_Checksum_Error ) or
       (self.Error.ConvError = SCE_length_Error) then //if a checksum/length error occurs , we enable further reads if sync is enabled (otherwise no way to resynchronize)
    begin
      //write('## Error detected ('+SCE_ToString(self.error)+') ## ');
//      if (self.InternalUseSync) and (Not Warning) then //only for the first warning
      //begin
//        write('.+x## Recovery action ##x+.');
        //write('Press return:'); readln;
        self.ResetState;
        idx := backtrack_pos; //backtrack since we have had a false sync marker.
        warning:= True; //if no further error occurs then remember to signal caller something bad happened
      //end;
    end
    else
    begin
      if self.HasError then
      begin
        self.InternalState:= SPS_Error;
        write('(unhandled error: ', SCE_ToString(self.Error),') ');
      end;
    end;

    if (idx <= length(Source)) then idx += 1;
    //write('/ idx=',idx,' l=',length(source),'/, ');
    //if self.IsDone then write('IsDone, ');
    //if warning then write('Warning!,') else write ('No warning, ');
    {$if DEBUGLVL >= 4}
    write(SCE_ToString(self.error) + '! ');
    {$endif}
  end;

  //writeln;
  //write('Stopped parsing: ');
  //write('/ idx=',idx,' l=',length(source),'/, ');
  //if self.IsDone then write('IsDone, ');
  //if warning then write('Warning!,') else write ('No warning, ');
  {$if DEBUGLVL >= 4}
  write(SCE_ToString(self.error) + '! ');
  {$endif}
  //writeln;
  {$if DEBUGLVL>=1}
  if not SCE_NoErrors(self.Error) then log.LogError('ParseString SCE error:'+ SCE_ToString(self.error) , INFOLINE , {$i %line%});
  {$endif}
  FoundItem := self.IsDone;
  {$if DEBUGLVL>=2}
  if not self.IsDone then log.LogWarning('ParseString found no item (Not isDone)' , INFOLINE , {$i %line%});
  {$endif}
  if (SCE_NoErrors(self.Error)) And FoundItem then
  begin
    value := self.TagData;
    Result.SetResult(copy(Source, idx, (length(Source) - idx) + 1));
    {$if DEBUGLVL>=3}
    log.LogStatus ('ParseString found item' , INFOLINE , {$i %line%});
    {$endif}
  end
  else
  begin
    FoundItem:=False;
    Result.SetResult(source);
    {$if DEBUGLVL >= 4}
    write('<<<*** ParseString found nothing ***>>>');
    {$endif}
  end;
//  if warning and (not SCE_HasErrors(self.Error)) then self.SetSceError(SCE_SkippedItem);
  if warning then
  begin
    self.SetSceError(SCE_SkippedItem);
//    writeln('Warning -> SetError (Skipped_item)');
//    write('Press return:'); readln;
  end;
  if self.HasError then Result.SetError(self.error);
  {$if DEBUGLVL >= 4}
  writeln('Parsestring error at return: "', SCE_ToString(self.Error),'" Result="', result,'"' );
  {$endif}
end;


function TStreamStringHandler.ParseString(Source:TUTF8String;Var Value:Variant; var FoundItem:boolean):TResUTF8String;
var Taggeddata:TTagData;

begin
  {$if DEBUGLVL >= 4}
  writeln('back to the future ->');
  {$endif}
  TaggedData:= InitTag;
  Result := self.ParseString(source, Taggeddata, FoundItem);
  Value  := Taggeddata.Value;
end;


function TstreamStringHandler.WriteStringToStream(AStream:TStream; value:TUTF8String; var ErrorCode:TStringConversionError):int64;
var
  Len: Int64;

begin
  Len := Length(value);
  Result := 0;
  ErrorCode := SCE_ClearError;
  if AStream = NIL then writeln('stream to write is NIL');
  //  writeln(' -> stream =', value);
//  AStream.Write(Len, SizeOf(Len)); //size is already embedded into strings using VariantToStreamString
  try
    AStream.Write(PChar(value)^, Len);
    result:=len;
    //writeln('TStreamStringhandler.WriteStringToStream Writes : "',value,'" and stream length of ',len );
  except
    on E: Exception do
    begin
      ErrorCode.ConvError := SCE_IOerror_Write_Error;
      result:=-1;
      {$if DEBUGLVL>=1}
      log.LogError( 'Write error exception :'+ E.ToString, INFOLINE , {$i %line%});
      {$endif}
    end;
  end;
end;


procedure TStreamStringHandler.WriteVariantToStream(AStream:TStream;
                               source:UnicodeString;
                               var ErrorCode:TStringConversionError);
begin
  ErrorCode.ConvError := SCE_NoError;
  WriteVariantToStream_ErrorFallThrough(AStream,source,ErrorCode);
end;

procedure TStreamStringHandler.WriteVariantToStream(AStream:TStream;
                               source:UTF8String;
                               var ErrorCode:TStringConversionError);
begin
  ErrorCode.ConvError := SCE_NoError;
  WriteVariantToStream_ErrorFallThrough(AStream,source,ErrorCode);
end;

procedure TStreamStringHandler.WriteVariantToStream(AStream:TStream;
                               source:variant;
                               var ErrorCode:TStringConversionError);
begin
  ErrorCode.ConvError := SCE_NoError;
  WriteVariantToStream_ErrorFallThrough(AStream,source,ErrorCode);
end;


procedure TStreamStringHandler.WriteVariantToStream_ErrorFallThrough(AStream:TStream;
                               source:UnicodeString;
                               var ErrorCode:TStringConversionError);
var
  Resstr:TResUTF8String;

begin
  {$if DEBUGLVL >= 2}
  writeln('intercepted unicode string');
  {$endif}
  if error.ConvError = SCE_NoError then
  begin
    Resstr:=self.VariantToStreamString(source);
    {$if DEBUGLVL >= 2}
    writeln('str:="', StringDumpToHexUTF8(str), '"');
    {$endif}

    if resStr.Success then
    begin
      try
        WriteStringToStream(AStream, ResStr.Result, ErrorCode);
      except
        on E: Exception do
        begin
          ErrorCode.ConvError := SCE_IOerror_Write_Error;
          {$if DEBUGLVL>=1}
          log.LogError( 'Write error exception :'+ E.ToString, INFOLINE , {$i %line%});
          {$endif}
        end;
      end;
    end
    else
    begin
      errorcode := ResStr.Error;
		end;
	end;
end;

procedure TStreamStringHandler.WriteVariantToStream_ErrorFallThrough(AStream:TStream;
                               source:UTF8String;
                               var ErrorCode:TStringConversionError);
var
  ResStr:TResUTF8String;
begin
  //{$if DEBUGLVL >= 3}
  //writeln('intercepted str');
  //{$endif}
//  if ErrorCode.ConvError = SCE_NoError then
  if not SCE_HasErrors(ErrorCode) then //in case of existing errors the error falls through
  begin
    ResStr:= self.VariantToStreamString_(source,'', #0);//VariantToStreamString(source, error);
    if ResStr.Success then
    begin
      try
        WriteStringToStream(AStream, ResStr.Result , ErrorCode);
      except
        on E: Exception do
        begin
          ErrorCode.ConvError := SCE_IOerror_Write_Error;
          {$if DEBUGLVL>=1}
          log.LogError( 'Write error exception :'+ E.ToString, INFOLINE , {$i %line%});
          {$endif}
        end;
      end;
    end;
    //else
    //begin
    //  writeln('****** error in WriteVariantToStream: VariantToStreamString failed with ', StringConversionErrorToString(error));
    //end;
  end;
end;

procedure TStreamStringHandler.WriteVariantToStream_ErrorFallThrough(AStream:TStream;
                               source:variant;
                               var ErrorCode:TStringConversionError);
var
  ResStr:TResUTF8String;
begin
  {$if DEBUGLVL>3}
  log.LogStatus('WriteVar2Stream vartype = '+ VarTypeAsText(vartype(source)), INFOLINE , {$i %line%});
  {$endif}
//  if ErrorCode.ConvError = SCE_NoError then
  if not SCE_HasErrors(ErrorCode) then
  begin

//    str:=self.VariantToStreamString(source, ErrorCode);
    ResStr:=self.VariantToStreamString_(source, '', #0);
    if ResStr.Success then
    begin
      WriteStringToStream(AStream, ResStr.Result, ErrorCode);
    end
    else
      ErrorCode:= ResStr.Error;
  end;
end;

function TStreamStringHandler.StreamReadString(AStream:TStream; no_of_bytes:UInt32):TResUTF8String;
var idx:uint32;
    ch:Char;
    ResultVal:Utf8String;
    ReadError:boolean;
begin
  ResultVal := '';
  //{$if DEBUGLVL >= 3}
  //write('StreamReadString (',no_of_bytes,') [');
  //{$endif}
  ReadError:= False;
  try
    for idx:=1 to no_of_bytes do
    begin
      if Astream.Size > 0 then
      Begin
        if Astream.Position < Astream.Size then
        Begin
	        ch := char(Astream.ReadByte);
	        {$if DEBUGLVL >= 4}
	        write('"', ch, '" ');
	        {$endif}
	        ResultVal:=ResultVal + ch;
				end;
			end;
		end;
  except
    on E: Exception do{ TODO -ouja : Better exception handling -> convert exceptions to errors and handle appropriately }
    begin
      ReadError:=True;
      {$if DEBUGLVL>=1}
      log.LogError( 'StreamReadString exception :'+ E.ToString, INFOLINE , {$i %line%});
      {$endif}
    end;
  end;
  if ReadError then
  begin
    self.SetSceError(SCE_IOerror_Read_Error);
    Result.SetWarning(ResultVal, self.Error);
  end
  else
    Result.SetResult(ResultVal);
end;

Function TStreamStringParser.StreamStringToVariant(streamstring:UTF8String;
                               VarexpectedType:TvartypeSet):TResVariant;
var Resvartupple:TResVariantTupple;
    errors:TStringConversionError;
begin
  errors := SCE_ClearError;
  ResVartupple:=StreamStringToVariantTupple(streamstring);
  if Resvartupple.Success = False then
  begin
    Result.SetFailure(Resvartupple.Error);
    exit(Result);
	end;

	if VarexpectedType <> vt_unknown then
  begin
    if (Resvartupple.Result.ID <> expectedType) then
    begin
      {$if DEBUGLVL>=1}
      log.LogError('Expected type <> recieved type' , INFOLINE , {$i %line%});
      {$endif}
      errors.ConvError:=SCE_Wrong_Type;
      Result.SetPartialFailure(Resvartupple.Result.value, errors);
      exit(Result);
    end;
  end;
  Result.SetResult(Resvartupple.Result.value);
end;

function TStreamStringHandler.ReadVariantFromSTream(Astream:TStream;
                               VarexpectedType:TvartypeSet):TresVariant;
var ErrorCode:TStringConversionError;
begin
  ErrorCode:= SCE_ClearError; //WE emulate the old behaviour by starting with no error
  Result := ReadVariantFromSTream_ErrorFallThrough(Astream,VarExpectedType,ErrorCode);
end;



function TStreamStringHandler.ReadVariantFromSTream_ErrorFallThrough(Astream:TStream; VarExpectedType:TvartypeSet;
                               var ErrorCode:TStringConversionError):TResVariant;

var
  vt : TResVariantTupple;
  NullVariant : Variant;

begin
  NullVariant := GetNulVariant(VarExpectedType); //To ensure we always return a valid expected value we generate a default (Nul) variant of the correct type0
  if ErrorCode.ConvError = SCE_NoError then //if we start with an error we simply skip the read.
                               //that way we can read multiple variables in a row and need no fancy error handlin
  begin
    vt := ReadVariantTupplefromStream(Astream );
    if not vt.Success then
    begin
      Result.setFailure(vt.Error);
		end
    else
		begin
      if  vt.Result.ID = VarExpectedType then
      begin
        Result.SetResult(vt.Result.value);
      end
      else
      begin
        {$if DEBUGLVL>=1}
        log.LogError('Expected type <> recieved type' , INFOLINE , {$i %line%});
        {$endif}
        ErrorCode:=SetSceError(SCE_Wrong_Type);
      end;
    end;
  end;
end;

//Function UnitTest_variant_functions(var success:boolean):Boolean;
//const
//  showit = False;
//var
//  var1,var1r:smallint;
//  var2,var2r:Integer;
//  var3,var3r:ShortInt;
//  var4,var4r:Byte;
//  var5,var5r:Word;
//  var6,var6r:LongWord;
//  var7,var7r:Int64;
//  var8,var8r:QWord;
//  varE,varEr:Single;
//  var9,var9r:Double;
//  varA,varAr:TDATE;
//  varB,varBr:Currency;
//  varC,varCr:Boolean;
//  varD,varDr:TUTF8String;
//  error:boolean;
//  error_SCE:TStringConversionError;
//
//  function RunSingleTest(varsource, vardest:variant;
//                         show_result:boolean;
//                         testresult:boolean):boolean;
//  var
//    errortext:TUTF8String;
//  begin
//    if show_result then
//    begin
//      writeln(varsource, ' , ', vardest, ' -> ', testresult);
//    end;
//
//    if testresult = False then
//    begin
//      errortext:='Error in conversion from '+VarTypeAsText(VarType(varsource))+
//                 ' to '+VarTypeAsText(VarType(vardest));
//      writeln(errortext);
//    end;
//    Result:=testresult;
//  end;
//
//begin
//  writeln('Test variant functions - Start');
//  if success then
//  begin
//    error:=False;
//    Randomize;
//    var1:= RandomRange(low(SmallInt),high(SmallInt));
//    var2:= RandomRange(low(Integer),high(Integer));
//    var3:= RandomRange(low(ShortInt),high(ShortInt));
//    var4:= RandomRange(low(Byte),high(Byte));
//    var5:= RandomRange(low(Word),high(Word));
//    var6:= RandomRange(low(LongWord),high(LongWord));
//    var7:= RandomRange(low(Int64),high(Int64));
//    var8:= RandomRange(low(LongWord),high(LongWord));
//    VarE:= Random;
//    var9:= Random;
//    varA:= Now;
//    varB:= RandomRange(0,100000000);
//    if random > 0.5 then varC:=True else VarC:=False;
//    varD:= 'abcdefghjklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
//
//    Var1r := StringTuppleToVariant(VariantToStringTupple(var1, vt_unknown), error_SCE); //smallint
//    Var2r := StringTuppleToVariant(VariantToStringTupple(var2, vt_unknown), error_SCE); //integer
//    Var3r := StringTuppleToVariant(VariantToStringTupple(var3, vt_unknown), error_SCE); //shortint
//    Var4r := StringTuppleToVariant(VariantToStringTupple(var4, vt_unknown), error_SCE); //byte
//    Var5r := StringTuppleToVariant(VariantToStringTupple(var5, vt_unknown), error_SCE); //word
//    Var6r := StringTuppleToVariant(VariantToStringTupple(var6, vt_unknown), error_SCE); //longword
//    Var7r := StringTuppleToVariant(VariantToStringTupple(var7, vt_unknown), error_SCE); //int64
//    Var8r := StringTuppleToVariant(VariantToStringTupple(var8, vt_unknown), error_SCE); //Qword
//
//    VarBr := StringTuppleToVariant(VariantToStringTupple(varB, vt_unknown), error_SCE); //currency
//    VarCr := StringTuppleToVariant(VariantToStringTupple(varC, vt_unknown), error_SCE); //Boolean
//    VarDr := StringTuppleToVariant(VariantToStringTupple(varD, vt_unknown), error_SCE); //string
//    Var9r := StringTuppleToVariant(VariantToStringTupple(var9, vt_unknown), error_SCE); //single
//    VarEr := StringTuppleToVariant(VariantToStringTupple(varE, vt_unknown), error_SCE); //Double
//    VarAr := VarToDateTime(StringTuppleToVariant(VariantToStringTupple(VarFromDateTime(varA), vt_unknown), error_SCE)); //Date
//
//    Result := RunSingleTest(var1,var1r,showit,var1 = var1r) And
//              RunSingleTest(var2,var2r,showit,var2 = var2r) And
//              RunSingleTest(var3,var3r,showit,var3 = var3r) And
//              RunSingleTest(var4,var4r,showit,var4 = var4r) And
//              RunSingleTest(var5,var5r,showit,var5 = var5r) And
//              RunSingleTest(var6,var6r,showit,var6 = var6r) And
//              RunSingleTest(var7,var7r,showit,var7 = var7r) And
//              RunSingleTest(var8,var8r,showit,var8 = var8r) And
//              RunSingleTest(varB,varBr,showit,varB = varBr) And
//              RunSingleTest(varC,varCr,showit,varC = varCr) And
//              RunSingleTest(varD,varDr,showit,varD = varDr) And
//  //Tests with floating point types
//              RunSingleTest(var9,var9r,showit,abs(1 - var9 / var9r) < single_error_tolerance) And
//              RunSingleTest(varE,varEr,showit,abs(1 - varE / varEr) < double_error_tolerance) And
//              RunSingleTest(varA,varAr,showit,abs(1 - varA / varAr) < double_error_tolerance);
//  end
//  else
//  begin
//    Result:=False;
//  end;
//  writeln('Test variant functions - End : Passed=', Result);
//
//end;


function is_escape_sequence(preceeding, current:char; ParseChars:TParseChars):boolean;
begin
  Result:=False;
  if preceeding = ParseChars.escape_char then
  begin
    if current = ParseChars.Quotes_Char then
      Result:=True
    else
      Result:=False;
  end;
end;




function ConvertEscapeSequence(indline:TUTF8String; ParseChars:TParseChars):TUTF8String;
var j:integer;
    result_str:TUTF8String;
    preceeding_char:char;
    in_quotes:boolean;
begin
  result_str:='';
  in_quotes:=False;
  preceeding_char:=' '; //any char not escape char
  for j:=1 to Length(indline) do
  begin
    //Toggle if we are in quotes or not.
    if (indline[j] = ParseChars.Quotes_Char)  then
    begin
      if in_quotes then
      begin
        //still has an error if we are in quotes
        if (preceeding_char <> ParseChars.escape_char) then
          in_quotes:=False;
      end
      else
        in_quotes:=True;
    end
    else
    begin
      if preceeding_char = ParseChars.escape_char then //We are not in quotes and if we had escape char before it was suppressed
      begin
        result_str := result_str + ParseChars.escape_char;
        {$if DEBUGLVL >= 4}
        write(indline[j]);
        {$endif}
      end;
    end;
    if (in_quotes) then //We store without question if we are within quotes
    begin
      //We suppress escape char but handle it through the preceeding mechanism shown above
      if (indline[j] <> ParseChars.escape_char) then
        result_str := result_str + indline[j];
    end
    else
    begin
      if ((indline[j]<>' ') AND (indline[j]<>#9) ) then //ignore space and tab
      begin
        result_str := result_str + indline[j];
      end;
    end;
    preceeding_char:=indline[j];
  end;
  Result := result_str;
end;


operator in (Val2: UTF8Char; Val1:UTF8String): boolean;
var
    idx_in_val1:SizeInt;
    current_char:UTF8Char;
begin
  if length(val1) = 0 then exit(false);
  current_char:= val2;
  for idx_in_val1:= 0 to length(val1) do
  begin
    if current_char = val1[idx_in_val1] then exit(true);
  end;
  Result:=False;
end;

operator in (Val1, Val2: UTF8String): boolean;
var
    idx_in_val1, idx_in_val2:SizeInt;
    current_char:UTF8Char;
begin
  if length(val1) = 0 then exit(false);
  if length(val2) = 0 then exit(false);
  for idx_in_val2 := 0 to length(val2)-1 do
  begin
    current_char:= val2[ idx_in_val2];
    if val1 in current_char then exit(true);
  end;
  Result:=False;
end;


type
  Tconvert_tupple = Record
                      char_to_escape: UTF8Char;
                      escaped_char: UTF8Char; //preceded by ECS_STRING_ESCAPECHAR
  End;

Const
    EscTupples : array [0..4] of Tconvert_tupple =
    (
      (char_to_escape: ECS_STRING_ESCAPECHAR;
        escaped_char: ECS_STRING_ESCAPECHAR), //this means that *two* ECS_STRING_ESCAPECHAR will be issued
      (char_to_escape: ECS_ESCAPECHAR;
        escaped_char: ECS_ESCAPECHAR_ALIAS),
      (char_to_escape: ECS_SYNCCHAR;
        escaped_char: ECS_SYNCCHAR_ALIAS),
      (char_to_escape: ASCII_LINEFEED;
        escaped_char: ECS_LINEFEED_ALIAS),
      (char_to_escape: ASCII_CARRIAGE_RETURN;
        escaped_char: ECS_CARRIAGE_RETURN_ALIAS)
    );

function Utf8Char_To_EscapedUtf8String(char_to_convert: UTF8Char):UTF8String;
var
  idx2: SizeInt;
begin
  Result := char_to_convert;
  for idx2:=low(EscTupples) to High(EscTupples) do
  begin
    if char_to_convert = EscTupples[idx2].char_to_escape then
    begin
      Result :=ECS_STRING_ESCAPECHAR + EscTupples[idx2].escaped_char;
    end;
  end;
end;

function EscapedUtf8Char_To_Utf8String(char_to_convert: UTF8Char):UTF8Char;
var
  idx2: SizeInt;
begin
  Result := char_to_convert;
  for idx2:=low(EscTupples) to High(EscTupples) do
  begin
    if char_to_convert = EscTupples[idx2].escaped_char then
    begin
      Result :=EscTupples[idx2].char_to_escape;
    end;
  end;
end;

function Utf8String_To_EscapedUtf8String(StringToConvert:UTF8String):UTF8String;
var
  idx: SizeInt;
  char_to_convert:UTF8Char;
  str_to_add : UTF8String;
begin
  Result:='';
  if length(StringToConvert) < 1 then exit(StringToConvert);
  idx := 1;
  while idx <= length(StringToConvert) do
  begin
    char_to_convert:= StringToConvert[idx];
    Result += Utf8Char_To_EscapedUtf8String(char_to_convert);
    idx += 1;
  end;
end;

function EscapedUtf8String_To_Utf8String(StringToConvert:UTF8String):UTF8String;
var
  idx: SizeInt;
  char_to_convert:UTF8Char;
  str_to_add : UTF8String;
begin
  Result:='';
  if length(StringToConvert) < 1 then exit(StringToConvert);
  idx := 1;
  while idx <= length(StringToConvert) do
  begin
    char_to_convert:= StringToConvert[idx];
    str_to_add:= '';
    if char_to_convert = ECS_STRING_ESCAPECHAR then
    begin
      idx += 1;
      if idx <= length(StringToConvert) then
      begin
        char_to_convert:= StringToConvert[idx];
        str_to_add := EscapedUtf8Char_To_Utf8String(char_to_convert);
      end;
    end
    else
    begin
      str_to_add := char_to_convert;
    end;

    Result += str_to_add;
    idx += 1;
  end;
end;


function test_UTF_escape_functions(ok:Boolean):boolean;
var str1, str1_backconverted: TTwoCharString;
  str1_escaped:UTF8String;
  error:TStringConversionError;

begin
  if not(ok) then exit(false);
  error := SCE_ClearError;
  str1 := 'æü€$@ÿí '+ECS_ESCAPECHAR + ECS_SYNCCHAR + ECS_STRING_ESCAPECHAR + ASCII_CARRIAGE_RETURN + ASCII_LINEFEED;
  str1_escaped:= Utf8String_To_EscapedUtf8String( TTwoCharStringToRawString(str1,error));
  str1_backconverted:= RawstringToTTwoCharString(EscapedUtf8String_To_Utf8String(str1_escaped),error);
  if not (str1 = str1_backconverted) then
  begin
    writeln('The escape conversion failed. Reconverted string did not match the original');
    writeln('Source :="',StringDumpToHex(str1),'"');
    writeln('Escaped:="',StringDumpToHexUTF8(str1_escaped),'"');
    writeln('result :="',StringDumpToHex(str1_backconverted),'"');
    exit(false);
  end;
  writeln('The escape conversion succeeded. Reconverted string matched the original');
  writeln('Source :="',StringDumpToHex(str1),'"');
  writeln('Escaped:="',StringDumpToHexUTF8(str1_escaped),'"');
  writeln('result :="',StringDumpToHex(str1_backconverted),'"');

  exit(true);
end;

//function inverse_escape_conversion(char_to_convert:UTF8Char; fromstr, tostr: UTF8String):UTF8Char;
//
//function Utf8ToUtf8StreamReady(indline:TUTF8String; ParseStr:TParseStrings):TUTF8String;
//var j:integer;
//    pos_in_str : SizeInt;
//    result_str:TUTF8String;
//    current_char:UTF8Char;
//    preceeding_char:char;
////    in_quotes:boolean;
//begin
//  result_str := '';
//  preceeding_char:=' '; //any char not escape char
//  for pos_in_str:= 0 to length(indline)-1 do
//  begin
//    current_char:= indline[pos_in_str];
//    if current_char in ParseStr.must_Escape_str then
//    begin
//      result_str:= result_str + ParseStr.escape_str + escape_conversion(current_char);
//    end
//    else
//    begin
//      result_str:= result_str + current_char;
//    end;
//  end;
//  Result := result_str;
//end;
//
//function Utf8StreamReadyToUtf8(indline:TUTF8String; ParseChars:TParseChars):TUTF8String;
//begin
//end;

function remove_whitespace(indline:TUTF8String; ParseChars:TParseChars):TUTF8String;
var j:integer;
//    result_str:TUTF8String;
    preceeding_char:char;
    in_quotes:boolean;
begin
  result:='';
  in_quotes:=False;
  preceeding_char:=' '; //any char not escape char
  for j:=1 to Length(indline) do
  begin
    //Toggle if we are in quotes or not.
    if (indline[j] = ParseChars.Quotes_Char)  then
    begin
      if in_quotes then
      begin
        //still has an error if we are in quotes
        if (preceeding_char <> ParseChars.escape_char) then
          in_quotes:=False;
      end
      else
        in_quotes:=True;
    end;
    if (in_quotes) then //We store without question if we are within quotes
    begin
      //We suppress escape char but handle it through the preceeding mechanism shown above
//      if (indline[j] <> escape_char) then
        result:= result + indline[j];
    end
    else
    begin
      if ((indline[j]<>' ') AND (indline[j]<>#9) ) then
      begin
        result := result + indline[j];
      end;
    end;
    preceeding_char:=indline[j];
  end;
end;

function ApproxEqual(value1:Single; value2:Single):boolean; //single precision
begin
  if abs(value1-value2) < single_error_tolerance then Result:=True else Result:=False;
end;

function ApproxEqual(value1:Single; value2:Double):boolean; //single precision
begin
  if abs(value1-value2) < single_error_tolerance then Result:=True else Result:=False;
end;

function ApproxEqual(value1:Double; value2:Single):boolean; //single precision
begin
  if abs(value1-value2) < single_error_tolerance then Result:=True else Result:=False;
end;


function ApproxEqual(value1:Variant; value2:Double):boolean; //single/double precision depending on variant
begin
  if VarType(value1) = varDouble then
  begin
    if abs(value1-value2) < Double_error_tolerance then Result:=True else Result:=False;
  end
  else
  begin
    if VarType(value1) = varSingle then
    begin
      if abs(value1-value2) < single_error_tolerance then Result:=True else Result:=False;
    end
    else
      Result:=False;
  end;
end;

function ApproxEqual(value1:Double; value2:Variant):boolean; //single/double precision depending on variant
begin
  Result:= ApproxEqual(Value2, value1); //calls other version of Approx Equal
end;

function ApproxEqual(value1:Double; value2:Double):boolean; //Double precision
begin
  if abs(value1-value2) < Double_error_tolerance then Result:=True else Result:=False;
end;

function ToObj(TagDat:TTagData):TTagObj;
begin
  Result := TTagObj.Create;
  Result.value := TagDat;
end;

Constructor TTagObj.Create;
begin
  self.SetDefault;
end;

procedure TTagObj.SetDefault;
begin
  self.value := InitTag;
end;


Function TTagObj.ToStreamString(StreamStrHandler:TStreamStringHandler; var Errors:TStringConversionError):TUTF8String;
begin
  Result := StreamStrHandler.TagToStreamString(self.value, Errors);
end;

function TTagObj.FromStreamString (StreamStrHandler:TStreamStringHandler; data:TUTF8String;
                           var FoundItem:boolean; Errors:TStringConversionError):TUTF8String;

begin
  if data <> '' then
  begin
    Result := StreamStrHandler.ParseString(data, self.value, FoundItem, errors);
    {$if DEBUGLVL >= 4}
    writeln;
    writeln;
    writeln('TTagObj: FromStreamString: remainder=(', result,'), FoundItem=',FoundItem,' value="',self.ToText,'"');
    {$endif}
  {$if DEBUGLVL >= 3}
  end
  else
    writeln('TTagObj: FromStreamString: Empty string recieved!');
  {$else}
  end;
  {$endif}

//  StreamStrHandler.SetSceError(errors); //Use if errors discovered in conversion needs to be added
end;

function TTagObj.ToText:TUTF8String;
begin
  result:= '<TTagObj(val="' + VarToStr(self.value.Value)  +'"'+
           ', AType=' + IntToString(self.value.TagAbstractType) +
           ', ID='+ IntToString(self.value.TagsId) +
           ', UType=' + IntToString(self.value.TagsUserType) + ')>';
end;

function ToObj(VariantData:Variant):TVariantObj;
begin
  Result:=TvariantObj.create;
  result.value:=VariantData;
end;

constructor TVariantObj.Create;
begin
  self.SetDefault;
end;

procedure TVariantObj.SetDefault;
begin
  self.value := Variant( Uint32(0));
end;

function TVariantObj.ToStreamString(StreamStrHandler:TStreamStringHandler; var Errors:TStringConversionError):TUTF8String;
begin
  Result := StreamStrHandler.VariantToStreamString(self.value, errors);
end;

function TVariantObj.FromStreamString (StreamStrHandler:TStreamStringHandler; data:TUTF8String;
                                 var FoundItem:boolean; Errors:TStringConversionError):TUTF8String;
var
  Tag:TTagData;
begin
  tag := InitTag;
  Result := StreamStrHandler.ParseString(data, tag , FoundItem, errors);
  if SCE_HasErrors(errors) then
  begin
    {$if DEBUGLVL>=1}
    log.LogError(' Parsestring error :' + SCE_ToString(errors), INFOLINE , {$i %line%});
    {$endif}
    self.value := Variant('<Null>');
  end
  else
  begin
    self.value := tag.value;
  end;
end;

function TVariantObj.ToText:TUTF8String;
begin
  Result:='<TVariantObj("' + VarToStr(self.value) +'") >';
end;

constructor TGenArray.create;
var
    errors:TStringConversionError;
begin
  inherited create;
  self.initialized:=False;
  StrHandler := TStreamStringHandler.Create;
  StrHandler.ResetIdCounter;
  StrHandler.ResetState;
  StrHandler.ActivateChecksum;
  StrHandler.ActivateSync;
  self.StrHandler.ReadOpen:=False;
  self.StrHandler.WriteOpen:=False;

  self.ClearArray;
end;

destructor TGenArray.destroy;
var idx:integer;
begin
  try
    try
      if self.StrHandler.ReadOpen or self.StrHandler.WriteOpen then
      begin
        {$I+}
          self.strhandler.CloseStream;
        {$I-}
      end;
    finally
      self.ClearArray;
      StrHandler.Destroy;
    end;
  finally
    try
      inherited Destroy;
    except
    end;
  end;
end;

//from :   operator + (TagArr: TTagArray; TagDat:TTagData):TTagArray;

function  TGenArray.GetError:TStringConversionError;
begin
  Result := self.StrHandler.Error;
end;

Procedure TGenArray.ClearError;
begin
  self.StrHandler.SetSceError(SCE_ClearError);
end;

procedure TGenArray.SetError(ErrorSet:TStringConversionError);
begin
  self.StrHandler.SetSceError(ErrorSet);
end;

procedure TGenArray.SetConversionError(ErrorSet:TStringConversionError_set);
var Errors:TStringConversionError;
begin
  errors:= SCE_ClearError;
  Errors.ConvError:=errorset;
  self.SetError(errors);
end;

function TGenArray._IsReadOpen:boolean;
begin
  result := self.StrHandler.ReadOpen;
end;

function TGenArray._IsWriteOpen:boolean;
begin
  result := self.StrHandler.WriteOpen;
end;

//function _ExpandArray(var TagArr:TTagArray):Uint32;
///// @short: Incremented in steps of 25% of the current size (note: minimum increase is 20 items),
///// Array index 0 value contains the number of used elements in the array. This value is not modified by this function.
//const
//  MinExpansion = 20; //Items
//  divisor = 4; //25 % is one forth of a full size -> 2 shifts
//var
//  len, expansion:int32;
//begin
////  if not SCE_NoErrors(err) then exit (0); //No expansion performed when errors are present
//  len := length(TagArr);
//  expansion :=  len div divisor;
//  {$if DEBUGLVL >= 4}
//  writeln('Len = ', len,' expansion=', expansion);
//  {$endif}
//  if expansion < MinExpansion then expansion:=MinExpansion;
//  {$if DEBUGLVL >= 4}
//  writeln('Len = ', len,' minexpansion=', expansion);
//  {$endif}
//  SetLength(TagArr, len + expansion);
//  Result := Length(TagArr);
//end;

function TGenArray.ExpandArray:Uint32;
/// @short: Incremented in steps of 25% of the current size (note: minimum increase is 20 items),
/// Array index 0 value contains the number of used elements in the array. This value is not modified by this function.
const
  MinExpansion = 20; //Items
  divisor = 4; //25 % is one forth of a full size -> 2 shifts

var
  len, expansion:Uint32;
begin
//  if not SCE_NoErrors(err) then exit (0); //No expansion performed when errors are present
  len := length(self.DataArray);
  expansion := len div divisor;

  if expansion < MinExpansion then expansion:=MinExpansion;

  try
    SetLength(self.DataArray, len + expansion);
    Result := Length(self.DataArray);
  except
    on E: Exception do
    begin
      self.StrHandler.SetSceError(SCE_MemoryError);
      self.strhandler.SetSceMeError(SCEME_error_1);

      {$if DEBUGLVL>=1}
      log.LogError( 'Expand array exception :'+ E.ToString, INFOLINE , {$i %line%});
      {$endif}
    end;
  end;
end;

function TGenArray.ItemsInArray:Integer;
begin
  result := self.ItemsInArray_priv;
end;

function TGenArray.InitializeArray:boolean;
var
  Len1:Uint64;
begin
  self.initialized:=True;
  Len1:=ExpandArray;
  if len1 = 0 then
  begin
    {$if DEBUGLVL>=1}
      log.LogError('Could not expand array in additem', INFOLINE , {$i %line%});
    {$endif}
    self.initialized:=False ;
    self.SetConversionError(SCE_MemoryError);
    self.strhandler.SetSceMeError(SCEME_error_2);

    exit(false);
  end;
  Result:= true;
end;

{$define DEBUGLVL:=4}
function TGenArray.AddItem   ( newitem:T2):integer;
var
  Len1,len2:Uint64;
  NewItemObj : T;
begin
  Len1 := (length(self.DataArray));
  if (len1 = 0)  then
  begin
    if not self.InitializeArray then exit(0);
    self.ItemsInArray_priv:=0;
    {$if DEBUGLVL>=3}
    log.LogStatus('Array init', INFOLINE , {$i %line%});
    {$endif}
  end;
  if not self.initialized then
  begin
    {$if DEBUGLVL>=1}
      log.LogError('Tries to expand non initialized array', INFOLINE , {$i %line%});
    {$endif}
    exit(self.ItemsInArray_priv);
  end;

  if (self.ItemsInArray_priv) >= Len1 then //Array needs to be expanded
  begin
    Len2:=ExpandArray;
    if len2 = 0 then
    begin
      {$if DEBUGLVL>=1}
        log.LogError('Could not expand array (memory)', INFOLINE , {$i %line%});
      {$endif}
      readln;
      self.SetConversionError(SCE_MemoryError);
      self.strhandler.SetSceMeError(SCEME_error_3);
      exit(0);
    end;
    {$if DEBUGLVL>=4}
    log.LogStatus('Array expand in add', INFOLINE , {$i %line%});
    {$endif}
    if len1 = len2 then //The array did not expand!!!
    begin
      //Result[0].TagAbstractType:=Uint8(TT_Error);
      {$if DEBUGLVL>=1}
      log.LogError('Did not really expand array (logic error)', INFOLINE , {$i %line%});
      {$endif}
      self.SetConversionError(SCE_Logic_error);
      exit(self.ItemsInArray_priv);
    end;
  end;
  try
     NewItemObj := T.Create;
     NewItemObj.value := NewItem;
     self.DataArray[self.ItemsInArray_priv]:=NewItemObj;
     self.ItemsInArray_priv := self.ItemsInArray_priv + 1;
     Result:=self.ItemsInArray_priv;
  except
    on E: Exception do
    begin
      {$if DEBUGLVL>=1}
      log.LogError('Exception detected!' + e.ToString, INFOLINE , {$i %line%});
      {$endif}
      self.SetConversionError(SCE_MemoryError);
      self.strhandler.SetSceMeError(SCEME_error_4);
    end;
  end;
end;
{$define DEBUGLVL:=1}

function TGenArray.RemoveItem( idx:integer):T;
begin
  try
    if (idx >= 0) and (idx < length(self.DataArray)) then
    begin
      delete (self.DataArray, idx, 1);
      self.ItemsInArray_priv:=self.ItemsInArray_priv - 1;
    end;
  except
    on E: Exception do
    begin
//      ErrorCode.ConvError := SCE_IOerror_Read_Error;
      self.SetConversionError(SCE_MemoryError);
      self.strhandler.SetSceMeError(SCEME_error_5);
      {$if DEBUGLVL>=1}
      log.LogError( 'Removeitem exception :'+ E.ToString, INFOLINE , {$i %line%});
      {$endif}
    end;
  end;

end;


function TGenArray.ClearArray:Boolean;
var
  idx:integer;
begin
  if not self.initialized then
  begin
    exit(false);
    {$if DEBUGLVL>=1}
    log.LogError( 'can''t clear not initialized array ', INFOLINE , {$i %line%});
    {$endif}
  end;
  if self.ItemsInArray > length(self.DataArray) then
  begin
    writeln('Error in arrray length');
    self.ItemsInArray_priv:= length(self.DataArray);
  end;
  if self.ItemsInArray > 0 then
  begin
    for idx := 0 to self.ItemsInArray-1 do
    begin
      try
        if Self.DataArray[idx] <> NIL then
        begin
          Self.DataArray[idx].Destroy;
          self.DataArray[idx] := NIL;
        end;
      except
        {$if DEBUGLVL >= 1}
        //on E:EAccessViolation do writeln (' EAccessViolation');
        //on E:EArgumentException do writeln (' EArgumentException');
        //on E:EArgumentNilException do writeln (' EArgumentNilException');
        //on E:EArgumentOutOfRangeException do writeln (' EArgumentOutOfRangeException');
        on E: Exception do
        begin
          writeln('Exception (',e.ToString,') in TgenArray destructor for items in array. Idx=',idx);
        end;
        {$endif}
      end;
    end;
  end;
  SetLength(self.DataArray,0);
  self.ItemsInArray_priv:=0;
  self.initialized:=False;
  Result:=True;
end;


// @short: Converts array to string that can be written
function TGenArray.ArrayToStreamStr(usertype: uint16; userid:uint64) :TUTF8String;
var
  ToIdx, Idx, MaxLen:UInt64;
  headerTag,FooterTag:TTagData;
  header, footer:TUTF8String;
  nextpart:TUTF8String;
  NextTaggedPart:TUTF8String;
  RecordData:T2;
  errors:TStringConversionError;
  UseStreamWrite:boolean;

begin
  errors:= SCE_ClearError;
  MaxLen := self.ItemsInArray; //Length(self.DataArray);
  Result:='';
  if self.StrHandler.WriteOpen then UseStreamWrite:=True else UseStreamWrite:=False;

  //needs to write array header
  //SCE_ArrayHeader_missing
  headerTag:= InitTag;
  headerTag.Value:= maxlen;
  headerTag.TagAbstractType:=TT_ArrayStart;
  headerTag.TagsUserType:=usertype;
  headerTag.TagsId:=userid;
  Self.StrHandler.ActivateChecksum; //enforce checksum
  Self.StrHandler.ActivateSync; //enforce sync
  nextpart := Self.StrHandler.TagToStreamString(headerTag,  errors);
  if UseStreamWrite then
  begin
    self.writeline(nextpart);
  end
  else
  begin
    Result := Result + NextPart;
  end;
  writeln('Header=', nextpart);

  ToIdx := MaxLen;
  idx := 0;
  while (idx < ToIdx) and (SCE_NoErrors(self.error) = True) do // length(TagArray)-1 do
  begin
    nextpart := self.DataArray[idx].ToStreamString(self.StrHandler, errors);
    if SCE_NoErrors(self.error) then
    begin
      {$if DEBUGLVL >= 4}
      writeln('Arr2Str [',idx,']="',nextpart,'" error ="', SCE_ToString(self.error),'" ');
      {$endif}
      if SCE_NoErrors(self.error) then
      begin
        if UseStreamWrite then self.writeline(nextpart) else Result := Result + NextPart;
      end;
    end;
    idx:= idx +1;
  end;

  if MaxLen > self.ItemsInArray_priv then MaxLen := self.ItemsInArray_priv;


  footerTag.TagAbstractType:=TT_item;
  footerTag.TagsUserType:=usertype;
  footerTag.TagsId:=userid;
  footerTag.TagAbstractType:= TT_ArrayEnd;
  FooterTag.Value:=MaxLen;
  nextpart := Self.StrHandler.TagToStreamString(FooterTag,  errors); //+ ECS_LINEENDING;
  writeln('Header=', nextpart);
  if UseStreamWrite then self.writeline(nextpart) else Result := Result + NextPart;
end;

function TGenArray.RecoverableError:boolean;
begin
  { #todo : evaluate what errors that are really recoverable }
  if (self.error.ConvError = SCE_NoError) or
     (self.error.ConvError = SCE_SkippedItem) or
     (self.error.ConvError = SCE_ArrayHeader_missing) or
     (self.error.ConvError = SCE_ArrayHeader_WrongUserType) or
     (self.error.ConvError = SCE_bracket_mismatch)
  then
    Result:= True
  else
    Result:= False;
end;


function TGenArray.ParseString(Source:TUTF8String;Var Value:TTagData; var FoundItem:boolean; Var ErrorCode:TStringConversionError):TUTF8String;
begin
  Result := StrHandler.ParseString(Source, Value, FoundItem, errorCoDe);
end;

function TGenArray.ParseString(Source:TUTF8String;Var Value:Variant; var FoundItem:boolean; Var ErrorCode:TStringConversionError):TUTF8String;
begin
  Result := StrHandler.ParseString(Source, Value, FoundItem, errorCoDe);
end;

//function TGenArray.ParseString(Source:TUTF8String;Var Value:TUTF8String; var FoundItem:boolean; Var ErrorCode:TStringConversionError):TUTF8String;
//Var NeWitem:Variant;
//begin
//  Result := StrHandler.ParseString(Source, NeWitem, FoundItem, errorCoDe);
//  if (VarType(NewItem)=varString) or (VarType(NewItem)=varOleStr) then
//  begin
//    if VarType(NewItem)=varString then
//      Result := NeWitem
//    else
//      Result :=TTwoCharStringToRawString(NeWitem, ErrorCode);
//    Result := TUTF8String(NewItem)
//  end
//  else
//    Result := '';
//end;

//Function TTagObj.ToStreamString(StreamStrHandler:TStreamStringHandler; var Errors:TStringConversionError):TUTF8String;

Function TGenArray.ItemToStreamString(idx_in_DataArray: uint32):TUTF8String;
var
  errors:TStringConversionError;
begin
  errors:= SCE_ClearError;
  Result:= self.DataArray[idx_in_DataArray].ToStreamString(self.StrHandler, errors);
end;

function TGenArray.GetNext(StrData:TUTF8String):TUTF8String;
var succeed:boolean;

begin
  Result:='';
  if self.StrHandler.UseStream then
  begin
    if not self.StreamOpenForRead then
    begin
//      self.StrHandler.OpenStreamForRead(self.StrHandler.CurrentStreamName);
      Self.SetConversionError(SCE_IOerror_StreamCreate_read_Error);
      write('***** Stream not open *****');
      exit(''); //return empty
    end;
    succeed := self.Readline(Result);

    if not succeed then
    begin
      {$if DEBUGLVL>=1}
      log.LogError('Could not read from self._currentstream.', INFOLINE , {$i %line%});
      {$endif}

      Result:='';
    end
    else
    begin
      writeln('GetNext Read from self._currentstream ="',Result,'"');
    end;
  end
  else
  begin
    write('(GetNext="',StrData,'") ');
    Result:= StrData;
  end;
end;


function TGenArray.StreamStrToArray(StreamStr:TUTF8String; var HeaderTag:TTagData):TUTF8String;
{ TODO -ouja : Both to strarray needs to be able to be cut into sections. The sections are needed to reduce memory requirements when storing large arrays. So the process now: array -> str is done in parts. This requires a statemachine to track the state of writing (see updatestatemachine for ex.) }
//Modifies this function to handle two different sources for input. The streamStr or self._currentstream
//if the stream is open for reading then disregard the streamstr input, but reads the input stream line by line until end of array is found (or until error)

//function TGenArray.StreamStrToArray(StreamStr:TUTF8String):TUTF8String;
Var
  Warning:boolean;
  FoundItem, ErrorRecovery:boolean;
  NewItem:T;
  Idx:integer;
  remainder:TUTF8String;
  errors:TStringConversionError;
  FooterTag:TTagData;
  header,footer:TUTF8String;
  maxlen:uint64;
  //usestream: boolean;

  //procedure debugline(lineno:string);
  //begin
  //  {$if DEBUGLVL>=4}
  //  write('<StreamStrToArray ', lineno, '> ');
  //  {$endif}
  //end;

begin
  //{$if DEBUGLVL>=4}
  //write('<StreamStrToArray.', INFOLINE , {$i %line%}, '> ');
  //{$endif}
  //debugline({$i %line%});
  errors:= SCE_ClearError;
  if (not self.StrHandler.ReadOpen) And (StreamStr = '') then
  begin
    {$if DEBUGLVL>=1}
    log.LogError('ERROR: No data source: No stream open and no string -> no data.', INFOLINE , {$i %line%});
    {$endif}
    self.SetConversionError(SCE_MemoryError);
    self.strhandler.SetSceMeError(SCEME_error_6);

    Result:='';
    exit(Result);
  end;
  Result:= StreamStr;
  Remainder:=StreamStr;
  FoundItem:=True;
  Warning:=False;
  //debugline({$i %line%});
  if not self.initialized then
  begin
    if not self.InitializeArray then
    begin
      {$if DEBUGLVL>=1}
      log.LogError('ERROR: Could not clear initialize internal array.', INFOLINE , {$i %line%});
      {$endif}
      self.SetConversionError(SCE_MemoryError);
      self.strhandler.SetSceMeError(SCEME_error_7);

      exit('');
    end;
  end;
  if not self.ClearArray then
  begin
    {$if DEBUGLVL>=1}
    log.LogError('ERROR: Could not clear internal array.', INFOLINE , {$i %line%});
    {$endif}
    self.SetConversionError(SCE_MemoryError);
    self.strhandler.SetSceMeError(SCEME_error_8);

    Result:='';
    exit(Result);
  end;
  //debugline({$i %line%});
  Self.StrHandler.ActivateChecksum;
  Self.StrHandler.ActivateSync;

  ErrorRecovery:=False; //Stop at first error do not try to continue
  remainder := GetNext(Remainder); //gets next section either from string or stream
  if remainder = '' then   remainder := GetNext(Remainder); //gets next section either from string or stream

  {$if DEBUGLVL>=1}
  log.LogWarning('Streamstrtoarray received "'+ remainder +'"', INFOLINE , {$i %line%});
  {$endif}
  remainder:= Self.ParseString(remainder, headerTag, FoundItem, errors);
  //debugline({$i %line%});

  if not founditem then
  Begin
    ErrorRecovery:=False;
    self.SetConversionError(SCE_ArrayHeader_missing);
    //self.InternalError.ConvError:=SCE_ArrayHeader_missing;
    {$if DEBUGLVL>=1}
    log.LogError('Header not found.', INFOLINE , {$i %line%});
    {$endif}
    exit('');
  end;
  //debugline({$i %line%});
  //function expects a value in a qword to come as first item
  if VarType(headerTag.Value) <> varQWord then
  begin
    {$if DEBUGLVL>=1}
    log.LogError('Unexpected variant type from header: wrong type recieved ('+
                 inttostring(uint16(VarType(headerTag.Value)))+') <> '+
                 inttostring(uint16(varQWord))+') for array size in tag.', INFOLINE , {$i %line%});
    {$endif}
    self.SetConversionError(SCE_ArrayHeader_missing);
    exit('');
  end;

  try
    newItem := T.create;
  except
    on E: Exception do
    begin
      {$if DEBUGLVL>=1}
      log.LogError('Exception in T.create ('+
                   inttostring(uint16(VarType(headerTag.Value)))+') <> '+
                   inttostring(uint16(varQWord))+') for array size in tag.', INFOLINE , {$i %line%});
      {$endif}
      self.StrHandler.SetSceError(SCE_MemoryError);
      self.strhandler.SetSceMeError(SCEME_error_9);

      exit(Result);
    end;
  end;
  MaxLen := headertag.Value; //the number of items in the stored array is stored as the value in the header tag
                             //If there are a CRC error there may be less items

  Idx:=0;
  while ((Length(remainder) > 0) And //if GetNext item is empty -> stop
         (FoundItem=True) And        //continue until no item is found
         (self.ItemsInArray_priv < maxlen) And
         (SCE_NoErrors(self.error) = True) ) do
  begin
    {$if DEBUGLVL >= 4}
    writeln('PreParse StrStr2Arr: Len(str)=', Length(streamstr),' FoundItem=', FoundItem);
    {$endif}
    errors := self.error;
    remainder := GetNext(Remainder);
    remainder := NewItem.FromStreamString( self.StrHandler, remainder, FoundItem, errors);
    self.SetError(errors);

    if SCE_HasErrors(self.error) then
    begin
      {$if DEBUGLVL >= 4}
      writeln('Errors detected');
      {$endif}
      warning:=True;
      if self.RecoverableError then
      begin
        self.ClearError;
        {$if DEBUGLVL >= 4}
        writeln('Cleared recoverable error');
        {$endif}
      end;
      {$if DEBUGLVL >= 3}
      log.LogWarning('Warning set due to errors in StreamStrToArray from ParseString' , INFOLINE , {$i %line%});
      {$endif}
    end;
    if FoundItem then
    begin
      StrHandler.ResetState;
      self.AddItem(NewItem.value);
      //write('StrStr2Arr: Value =', NewItem.ToText);
      //writeln;
      //write('(StrStr2Arr -> ArrayAdd:', NewItem.ToText,') ');
    end
    else
    begin
      {$if DEBUGLVL >= 1}
      log.LogWarning('Item not found in string for array' , INFOLINE , {$i %line%});
      {$endif}
      {$if DEBUGLVL >= 4}
      writeln('Item not found in string for array' , INFOLINE , {$i %line%});
      {$endif}
    end;
  end;
  NewItem.Destroy;
  StrHandler.ResetState;
  if warning then
  begin
    self.StrHandler.SetSceError(SCE_SkippedItem);
    {$if DEBUGLVL >= 3}
    log.LogWarning('StreamStrToArray SCE_SkippedItems - May have skipped items due to errors in one or more items' , INFOLINE , {$i %line%});
    {$endif}
  end;

  remainder := GetNext(Remainder);
  remainder:= Self.ParseString(remainder, FooterTag, FoundItem, errors);
  if not founditem then
  Begin
    ErrorRecovery:=True;
    {$if DEBUGLVL >= 1}
    log.LogError('Footer not found.' , INFOLINE , {$i %line%});
    {$endif}
    {$if DEBUGLVL >= 4}
    writeln('Footer Not found' , INFOLINE , {$i %line%});
    {$endif}
    exit( Result );
  end;
  if VarType(headerTag.Value) <> varQWord then
  begin
    {$if DEBUGLVL >= 1}
    log.LogError('Unexpected variant type from header:'+VarTypeAsText(VarType(headerTag.Value)), INFOLINE , {$i %line%});
    {$endif}
    exit('ERROR:Unexpected variant type from header');
  end;
  MaxLen := headertag.Value;
  Self.StrHandler.ActivateSync;

  errors := self.StrHandler.Error;
  Result := Remainder;
  //writeln('StreamStrToArray returns ',self.ItemsInArray,' items with error=', SCE_ToString(errors));
end;



function TGenArray.ErrorToString:TUTF8String;
begin
  Result := SCE_ToString(self.error);
end;

function TGenArray.HasError:boolean;
begin
  Result := SCE_HasErrors(self.error);
end;

function TGenArray.NoError:boolean;
begin
  Result := SCE_NoErrors(self.error);
end;

function TGenArray.StringToEscapedString(StringToWrite:TUTF8String):TUTF8String; //package <lf> -> <esc><lf>
begin
  Result:=StringToWrite;
  writeln('TGenArray.StringToEscapedString needs to be done!!!!');
end;

function TGenArray.EscapedStringToString(StringToWrite:TUTF8String):TUTF8String; //unpackage <esc><lf> -> <lf>
begin
  Result:=StringToWrite;
  writeln('TGenArray.EscapedStringToString needs to be done!!!!');
end;

function TGenArray.OpenRead(filename:TUTF8String):boolean;
begin
//  write(' Tries to open "', filename, '"   ');
  Result:=self.StrHandler.OpenStreamForRead(filename);
//  write(' - Open result: "', self.ErrorToString, '"   ');
end;

function TGenArray.OpenReWrite(filename:TUTF8String):boolean;
begin
  self.StrHandler.WriteOpen:=False;
  Result:=self.StrHandler.OpenStreamForWrite(filename, True);
  if SCE_NoErrors( self.error) then
  begin
    self.StrHandler.WriteOpen:=True;
    Write(' Stream rewrite OK. ');
  end
  else
  begin
    Writeln(' *** Stream rewrite failed *** ');
  end;
end;

function TGenArray.OpenAppend(filename:TUTF8String):Boolean;
begin
  Result:=self.StrHandler.OpenStreamForWrite(filename, False);
end;

function TGenArray.CloseFile:boolean;
begin
  self.StrHandler.closestream;
  Result := SCE_NoErrors(self.StrHandler.Error);
end;

function TGenArray.writeline(StringToWrite:TUTF8String):Boolean;
var
  errors:TStringConversionError;
begin
  Result:=False;
  if self.StrHandler.OpenForWrite then
  begin
    errors:= SCE_ClearError;
    self.StrHandler.WriteStringToStream(self.StrHandler._CurrentStream, StringToWrite + ECS_LINEENDING, errors);
    if SCE_HasErrors(self.StrHandler.Error) then
    begin
      Writeln('Write str to stream failed !');
      Result:=False
    end
    else
    begin
      Result:=True;
    end;
  end
  else
  begin
    Writeln('Nowhere to write: self.StrHandler.OpenForWrite=', self.StrHandler.OpenForWrite);
  end;
end;

function TGenArray.Readline(var StringToRead:TUTF8String):Boolean;
///@short reads a line from self._currentstream one char at time until LINEENDING is read
var
  res: TUTF8String;
  ReadError:boolean;
begin
  StringToRead:= '';
  ReadError := False;
  //c:= #0;
  res := #0;
  if self.StrHandler.OpenForRead then
  begin
    While ( not ReadError ) and (res <> ECS_LINEENDING) do
    Begin
      res := self.StrHandler.StreamReadString( self.StrHandler._CurrentStream, 1, ReadError);
      if self.HasError then
      begin
        ReadError:=True;
        {$if DEBUGLVL >= 1}
        log.LogError('Readline read error:"'+SCE_ToString(self.error)+'"' , INFOLINE , {$i %line%});
        {$endif}
        {$if DEBUGLVL >= 4}
        writeln('Unexpected variant type from header:'+VarType(headerTag.Value) , INFOLINE , {$i %line%});
        {$endif}
      end
      else
      begin
        StringToRead:= StringToRead + res;
      end;
    end;
    if ReadError then
    begin
      self.SetConversionError(SCE_IOerror_Read_Error);
      writeln(' ~~~ line read error ~~~ ');
    end;
  end
  else
  begin
    self.SetConversionError(SCE_IOerror_StreamCreate_read_Error);
  end;
end;


//function FindChar_but_skip_quotes(str:string; ch:Char; startpos:integer):integer;
//  var i:integer;
//      in_quotes :boolean;
//      preceeding_char:char;
//begin
//  i:=startpos;
//  preceeding_char:=' '; //anything but escape_Char
//  //write ('FCBS : startpos = i =', i,' ! ');
//  if i < length(str) then
//  begin
//    in_quotes:=False;
//    while (i<length(str)) and ((str[i]<>ch) or (in_quotes)) do
//    begin
//      if (str[i] = Quotes_Char) and (preceeding_char <> escape_char) then
//      begin
//        if in_quotes then in_quotes:=False else in_quotes:=True;
//      end;
//      preceeding_char:=str[i];
//      i:=i+1;
//      //write ('<FCBS loop: i =', i,' > ');
//    end;
//    if (str[i]=ch) then
//    begin
//      //write ('<FCBS: Found at: ',i,'> ');
//      result:=i;
//    end
//    else
//    begin
//      //write ('<FCBS error:did not find> ');
//      Result:= FINDERROR_DID_NOT_FIND;
//    end;
//  end
//  else
//  begin
//    //write ('<FCBS error:beyond> ');
//    Result:=FINDERROR_POSITION_BEYOND_STRING;
//  end;
//end;




end.

